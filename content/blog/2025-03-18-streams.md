+++
title = "Declarative and asynchronous"
description = "Declarative/functional asynchronous programming in Rust with streams and sinks."
[taxonomies]
tags = ["functional", "asynchronous", "declarative"]
+++


## Introduction

Let's get started with some definitions you may have heard about already.

**Declarative programming** is when you write code and make sure  that the inputs and outputs of sub-modules behave predictably according to fixed invariants. Logic or constraint solver languages like Prolog or [ManyWorlds](https://manyworlds.site/) (written by my friend [Jo Devriendt](https://jodevriendt.com)) are part of this family.

**Functional programming** is building the majority of your code from wel-defined and side-effect-free functions. It is a sub-set of declarative programming. Languages like ML, Haskell, OCaml, Lisp are part of this family. They are all extensions of Lambda Calculus.

**Asynchronous programming** is a kind of programming where you not only have functions that evaluate immediately, but there are also functions that _may evaluate in the future_. Such functions are called asynchronous functions. JavaScript, C# and Rust are examples.

In the following I will show how declarative, functional and asynchronous programming can be combined in the Rust programming language with the semi-standard library crate `futures`.


## Use-cases

Imagine you would not want to do any kind of functional asynchronous programming. What would that look like? 

It would just look like asynchronous programming and the `async`, `await` keywords with imperative keywords like `while`, `loop` or `continue`.


### Channels

One approach that you might take when dealing with different sub-modules in a large project is using channels to communicate between the different modules.

This could look like this:

```rust
let (_, in_receiver) = watch::channel(1);
let (out_sender, _) = broadcast::channel(123);
let forward_task = spawn(async move {
    loop {
        let result = in_receiver.changed().await;
        if let Err(e) = result { break };
        let input = *in_receiver.borrow();
        let output = get_output(input);
        out_sender.send(output);
    }
});
```

In this example I use `Tokio` "watch" and "broadcast" channels.

If we would translate this to a functional asynchronous version, we get:

```rust
let in_receiver = WatchStream::new(in_receiver);
let out_sender = BroadcastSink::new(out_sender);

let forward_task = spawn(
    in_receiver
    .map(Result::ok)
    .filter_map(ready)
    .map(get_output)
    .map(Ok)
    .forward(out_sender)
)
```

So what happened during the translation? 

- Replace the channel receiver with an implementor of the trait `Stream` from `futures`. A **stream** is just something to produces data at possibly irregular intervals. A channel receiver is an example of this. 
- Replace the channel sender with a type implementing the  `Sink` trait from `futures`. A **sink** is something that receives data, agnostic from the transport or channel used.
- **Redirect** the stream into the sink. This process could be seen as "flushing" the stream into the sink. However, the `flush` name is already taken by the `flush` method of the `Sink` trait.


A side effect of this is that we replace N intermediate variables in the loop by N-1 `map` functional operations. This is where the functional aspect comes in.

### Reactive UI input

Another place where functional asynchronous programming is useful, is on the frontend. 

An imperative version might look like this:

```rust
let mut target_temperature = 21.0;
slider.on_slide(move |new_t| {
    if acceptable(new_t) {
        let new_target = some_op(new_t);
        target_temperature = new_target;
    }
});
```

One problem with this code is that it has a lot of indentation and different branches, even though it is quite simple. It also requires the maintainer to maintain a little more variable names. 

Translating this to functional asynchronous Rust:

```rust
let mut target_temperature = sink(21.0);
slider.value
    .filter(acceptable)
    .map(some_op)
    .forward(target_temperature);
```

In mainstream web-frameworkds the `sink` will be called a "signal" or "writable observable".


## First observations

Instead naming the inputs and outputs, we focus on naming the transformations itself. The successive application of the transformations/functions is slightly easier to read for me. 

Another benefit of the functional approach is that it does not rely on a concrete type. `Stream` and `Sink` are universal traits (or interfaces). If you make use of these traits, which describe a common behaviour, and implement them for your own types, you make your code more interoperable with the rest of the world.

On the other hand, on the consumer side, a consumer of a functional library using these traits does not need to know the implementation details. It is not required how the data exactly moves in the dependency. I like to think of it as:

- The **trait**-level: describes the invariants and properties of inputs and outputs
- The **concrete type** level: describes the transport, the speed, the efficiency, the logic
  

**Important**: It is important to know while using Rust that it is not required to know everything about `Pin` or `Poll`. You can just use the high-level methods provided by the standard library and `futures` crate.


## Simple building blocks 

The main thing that is added in functional asynchronous program is the `Stream` trait. You are supposed to use it everywhere. There are other things of course, but this is the main concept that you will need.

So what is a **stream**? It is just something that implements the `Stream` trait from the `futures` crate. It nothing more than an asynchronous iterator.

A rough conceptual definition of a stream would be:

> A function that returns multiple values at unpredictable times.

First, remember that the life-time of an iterator (a normal synchronous blocking one) looks like this:

| T   | create     | iterate     | yield     | end    |
| --- | ---------- | ----------- | --------- | ------ |
| 0   |            |             |           |        |
| 1   | `(1..=10)` |             |           |        |
| 2   |            | `it.next()` |           |        |
| 3   |            |             | `Some(1)` |        |
| 4   |            | `it.next()` |           |        |
| 5   |            | `1+1`       |           |        |
| 6   |            | `it.next()` |           |        |
| 7   |            |             |           | `None` |

Here, I put the `1+1` to represent a random unrelated computation.

The life-time of a stream/async iterator during usage looks like this:

| T   | create      | iterate     | yield     | null   |
| --- | ----------- | ----------- | --------- | ------ |
| 0   |             |             |           |        |
| 1   | `St::new()` |             |           |        |
| 2   |             | `st.next()` |           |        |
| 3   |             | `await`     |           |        |
| 4   |             |             | `Some(1)` |        |
| 5   |             | `it.next()` |           |        |
| 6   |             | `1+1`       |           |        |
| 7   |             | `await`     |           |        |
| 8   |             |             | `Some(2)` |        |
| 9   |             | `it.next()` |           |        |
| 10  |             | `await`     |           |        |
| 11  |             |             |           | `None` |
| 12  |             | `it.next()` |           |        |
| 13  |             | `await`     |           |        |
| 14  |             |             | `Some(3)` |        |


This is longer and more complicated than a normal iterator. An async iterator requires an `await` before a value is yielded. 

As you can see in the last table, streams may yield `None` at first and later on still yield a `Some`. This is very different from iterators. Keep this in mind, especially further on, when creating your own streams. If you do not like this behaviour, you have to restrict your focus to `FusedStream`.


## Basic usage of streams

Before we dive into how streams are actually built in Rust, I would like to show you how to use a stream. You will notice that the methods on a stream are very similar to `Iterator`.

The most basic operation is of course `st.next()`. This will create a future that references the stream and evaluates to a next item or `None`.


**Remark**: As of April 25, all the methods you need for streams are in [`StreamExt`](https://docs.rs/futures/latest/futures/stream/trait.StreamExt.html) from `futures`. For the rest of this article, almost all `Stream`-related methods come from this trait.


### Consuming streams

The simplest case would be the case where you just want to perform an operation for each element that is yielded by the stream. For this, you should use the `for_each` method to act on each `Some` item.

```rust
let mut x = 0;
let fut = stream::repeat(1).take(3).for_each(|item| {
    x += item;
    future::ready(())
});
fut.await;
assert_eq!(x, 3);
```


Observe that the argument for the closure in `for_each` does not take an `Option`. The stream returned by `for_each` is fused, it is an implementor of `FusedStream`. It terminates as soon as one output item from the input stream is a `None`.

Also notice that the output of the closure has to be a future. But it does not need to await anything, so we use the `ready` future, the simplest possible future without any await points.

**Important**: 

- The futures that are evaluated while consuming the `for_each` will not overlap in execution. They will happen sequentially. 
- The `for_each` will not do any work, unless it is **driven** by an asynchronous executor. The reason is that streams are _lazy_, just like normal iterators in Rust.


Very often we just have to apply one blocking, synchronous operation to every output item from an input stream and return a new stream with the mapped items.

```rust
let stream = stream::iter(1..=3);
let stream = stream.map(|x| x + 3);
```

When the operation in the closure is asynchronous you should use `then` (as in `Future::then`).

```rust
let stream = stream::iter(1..=3);
let stream = stream.then(|x| async move { convert(x).await });
```





Feel free to use async closures `async |_| {}` or `AsyncFn` in recent Rust versions. 

I prefer to stick to the good-old `async move {}` blocks.

**Important**: In previous major version releases of `futures`, `then` and `map` were a single function. The crate `futures-preview` is an old fork such an old version. Avoid it's documentation to prevent confusion. (Everything you need for the rest of this presentation is available in the recent official release of `futures`.)

<!-- end_slide -->


### Simple modifications of a stream (useful in tests)

Common functions, similar to `Iterator`:

- skip_while
- peekable
- take

Example:

```rust
let stream = stream::iter(vec!['a', 'b', 'c']);

let mut stream = stream.enumerate();

assert_eq!(stream.next().await, Some((0, 'a')));
assert_eq!(stream.next().await, Some((1, 'b')));
assert_eq!(stream.next().await, Some((2, 'c')));
assert_eq!(stream.next().await, None);
```

<!-- end_slide -->

### Filtering streams

```rust
use std::future::ready;
use futures::{stream, StreamExt};

let stream = stream::iter(1..=10);
let events = stream.filter(|x| ready(x % 2 == 0));
```

Notice the `ready` function. It maps sync values into async values / futures **which are `Unpin`**.

Because the closure is `Unpin`, the resulting  `Stream` called `events` is also `Upin`.


#### Misleading messages compiler

Remark: the following would be an `Unpin` stream:

```rust
stream.filter(|x| async move { x % 2 == 0});
```

The compiler messages will lead you to pinning on the heap and you will do something like this:

```rust
stream.filter(|x| Box::pin(async move { x % 2 == 0}));
Box::pin(stream.filter(|x| async move { x % 2 == 0}));
stream.filter(|x| async move { x % 2 == 0}).boxed();
```

However, this is not necessary and involves **unnecessary heap allocations**. Use the `std::future::ready` function from above instead.

<!-- end_slide -->

### Filter map

The `filter_map` operator:
- takes a stream and a closure that returns an option
- removes `None` values, shortening the output stream

```rust
let stream = stream::iter(1..=10);
let events = stream.filter_map(|x| async move {
    if x % 2 == 0 { Some(x + 1) } else { None }
});
```

<!-- end_slide -->

### Boolean operators

There are also analogues for all boolean operators from `Iterator`: any, all, ...

```rust
let number_stream = stream::iter(0..10);
let less_then_twenty = number_stream.all(|i| async move { i < 20 });
assert_eq!(less_then_twenty.await, true);
```

<!-- end_slide -->


## Intermediate usage of streams

We will see:

- Merging
- Splitting
- Flushing


<!-- end_slide -->

### Requirements to merge streams

We also want to **combine streams**.

The input streams need to be of the same type.

This may be annoying whent you:

- build software with streams from different third-party crates 
- use different streams with different backend / transport.

Solution: use a `&dyn Stream` **behind a pointer** such as `Box` (heap-allocation).

References to streams in local variables on the stack are also possible, but then you do not have ownership. Ownership is typically needed.

<!-- end_slide -->


### Merge two homogenous streams

A user of streams does not just want to redirect or map streams.

Merge two homogenous streams with `tokio_stream::StreamExt::merge`. Disadvantage: dependency on `tokio-stream`.


<!-- end_slide -->


### Merge an iterable of streams

Merge normal iterator of streams into one stream with `futures::stream::select_all`.

```rust
let stream_a = stream::repeat(1);
let stream_b = stream::repeat(2);

let merged_tagged = stream::select_all([stream_a, stream_b]);
```

See [docs](https://docs.rs/futures/latest/futures/stream/fn.select_all.html).


<!-- end_slide -->

### Merging a keyed iterable of streams

To keep track of the origin of the values in the merged stream, do this:

```rust
let stream_a = stream::repeat(1).map(|n| ('a', 1));
let stream_b = stream::repeat(2).map(|n| ('b', 2));

let merged_tagged = stream::select_all([stream_a, stream_b]);
```


Remark: in this simple case you are be better off just using `tokio_stream::MergeMap`.


<!-- end_slide -->
### Inhomogenous stream merging


Merge two inhomogenous streams with `futures::StreamExt::zip` into a stream of tuples.

Or use trait objects and streams of type `Stream<Item: Box<dyn Trait>>`.

See later for more advanced types of merging.


<!-- end_slide -->

### The problem of splitting streams

What if you need to use the same output of a stream in several places and the items are `Clone`?

Most streams are **not `Clone`**, even if the items are `Clone`. 

The `Stream` trait is very basic and does not say how to clone.


Use a library:

- [my implementation](https://github.com/wvhulle/forked_stream): more tests, no Tokio dependency.
- [fork_stream](https://crates.io/crates/fork_stream), slightly more complicated with a Waker queue.
- [shared_stream](https://docs.rs/shared_stream/latest/shared_stream/): using `unsafe`, no tests.


<!-- end_slide -->

### Dual of streams: `Sink`s

You can forward a stream into a sink.

The `futures::Sink` trait is the opposite of `Stream`.


| stage    | name       | method             | meaning                | remark          |
| -------- | ---------- | ------------------ | ---------------------- | --------------- |
| creation | new        |                    | Initial state          |                 |
| send     | ready      | `ready().await`    | Wait until cache ready | may be full     |
| send     | start send | `start_send(item)` | Load into cache        | not actual send |
| send     | flush      | `flush().await`    | Send items from cache  |                 |
| close    | close      | `close().await`    | Close the `Sink`       | not automatic   |

The opposite for `map` for sinks is `with`.


If a `Sink` becomes full easily, you can allocate a buffer with `buffer()`.

<!-- end_slide -->

### Flushing a `Stream` into a `Sink`

A stream can be **sent into a sink** with `futures::SinkExt::forward`.

If you don't want to close the `Sink` after stream returned `None`, use `send_all`.

Third-party crates rarely have `impl` for `futures::Sink`.


```rust
let (output,_) = tokio::sync::mpsc::channel();
let output = tokio_util::PollSender::new(output);

let input = stream::repeat(1).map(Ok);
input.forward(tx).await.unwrap();
```

Important: 

- `StreamExt::forward` takes a `TryStream` (items are `Result`)
- returns future of `Result` (need to ignore error).


When you have one input stream and know `n` output sinks **at compile-time**, you can use `fanout`.

Otherwise you will have to do book-keeping yourself and spawn helper threads/tasks.


<!-- end_slide -->

## Streams from scratch

We will see:

- Creating streams imperatively
- Creating streams declaratively
- Creating streams through custom combinators

<!-- end_slide -->

### Iterators from imperative generators

In computer science, functions that may return more than one value are called **generators**.

(They are common in JavaScript and Python.)

On Rust 2024, generators are part of the core language through `gen` blocks. 

They **return an invisible iterator** of type `impl Iterator`.

```rust
gen {
    yield 1;
    yield 2;
    yield 3;
}
```

Generators are a kind of **imperative iterator construction**. 

Generators are a type of coroutines, see later.

<!-- end_slide -->

### Stable stream generators (imperative)

We need a macro, because `gen` blocks are **not in edition 2021 or stable yet**.

Use crate `async-stream`.

```rust
use async_stream::stream;

use futures_util::pin_mut;
use futures_util::stream::StreamExt;

let s = stream! {
    for i in 0..3 {
        yield i;
    }
};

pin_mut!(s); 

while let Some(value) = s.next().await {
    println!("got {}", value);
}
```

Notice that the stream returned by this macro is not pinned yet.

Streams generated by async generators  such as `async_stream::stream!` suffer from the same limitations as `async {}` blocks and most futures. They are `!Unpin`.


<!-- end_slide -->

### Nightly stream generators

Writing `async` in front of the `gen` keyword turns the output into a `Stream`, under the **new official name `AsyncIterator`**.

```rust
fn create_my_generator() -> impl AsyncIterator<Item = i32> {
    async gen {
      yield 1;
      yield 2;
      yield 3;
    }
}

let mut my_generator = create_my_generator();
assert_eq!(my_generator.next(), Some(1));
```


<!-- end_slide -->

### Simple declarative streams

You can use one of the methods

- `stream::once()`: stream of length 1
- `stream::iter()`: stream from iterable
- `stream::repeat()`: stream of identical values



<!-- end_slide -->

### Intermediate declarative streams

You can use an initial state, and a closure with `unfold`.

The initial state is mapped to an `Stream::Item` and new unfold `State`.


```rust
use futures::{stream, StreamExt};

let stream = stream::unfold(0, |state| async move {
    if state <= 2 {
        let next_state = state + 1;
        let yielded = state * 2;
        Some((yielded, next_state))
    } else {
        None
    }
});

let result = stream.collect::<Vec<i32>>().await;
assert_eq!(result, vec![0, 2, 4]);
```



<!-- end_slide -->

## Review of low-level move-prevention

This chapter reviews the low-level basics of asynchronous programming in Rust.

- What is `Unpin`?
- What is the role of `Pin`?
- What is a future low-level?
- Example of `!Unpin` type
- What is a stream low-level?

If you really want to know what `await` is, you can continue reading this chapter.


<!-- end_slide -->

### Immoveable / `Unpin`

Rust has **move semantics**. Assigning variables likely moves the content.

Self-referencing data types are dangerous to move. A move will invalidate the content without updating self-references.

The solution in Rust is to not update references, but mark self-referencing types as **not `Unpin`** / `!Unpin`.

(The double negation makes it a bit hard to understand.)

My interpretation of `Unpin` types: 

> All types for which the compiler can see that it is safe to move by **quickly looking at fields**.

Or in other words:

> Immoveable = `!Unpin`
> Moveable = `Unpin`

Remark: `Unpin` cannot be implemented manually, it's an auto-trait reserved for the compiler (on stable).


<!-- end_slide -->

### `Pin` as an `Unpin` consumer

`Pin` is nothing but a wrapper with no intrinsic value.

However, the most important safe functions of `Pin` require `item: Unpin`

- `Pin::new(item)`: pin a move-able object by telling the compiler not to move it 
- `Pin::get_mut(self)`: get mutable access to the object but no ownership

Edit access / mutable reference is dangerous when `Type: !Unpin` because you could still move the content with `std::mem::replace`.

Pin has `unsafe` counterparts to the above which do not have checks for `Unpin`.

Beware of the destructor in `Drop` for pinned types. It is still called.

<!-- end_slide -->

### Interpeting `Pin` as a barrier


The `Pin` type is a **barrier that protects us from moving types** that are `!Unpin` (types explicitly marked as not `Unpin` by the compiler).

| *Metaphor*   | *Type state*               | *Ownership event*   |
| ------------ | -------------------------- | ------------------- |
| _undressed_  | `Type`                     | moveable  / free    |
| _dress-up_   | `Pin::new(Type)`           | give up ownership   |
| _dressed-up_ | `Pin<Type>`                | stuck in memory     |
| _dress-down_ | `Pin::new(Type).get_mut()` | acquire edit access |


This means that `Pin`:
- is nothing more than a barrier. 
- does not have physical or type meaning on itself. 

`Pin` only has meaning when you interact with it through it's methods `new` and `get_mut`.



Why so complicated? 

I don't see a simpler alternative. Updating references manually would have a large overhead ...

<!-- end_slide -->



### Future trait

The future trait is a simplistic version of the stream trait.

Every synchronous / primitive data type value can be turned into a future.

A future that makes a value nullable and just returns the non-null part immediately on `await`-ing / polling.

```rust
pub struct Ready<T>(Option<T>);

impl<T> Future for Ready<T> {
    type Output = T;

    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<T> {
        Poll::Ready(self.0.take().expect("Ready polled after completion"))
    }
}
```
Usage:

```rust
let a = 1;
let fut = Ready::new(a);
// or
let fut = ready(a);

// will terminate immediately
let b = fut.await;

assert_eq!(a,b);
```

Remark: `.await` automatically converts everything in a future with `IntoFuture`.

<!-- end_slide -->

### Examples of `!Unpin` types


There a couple of examples of common types that are not safe to move:

- (async) generators, for example `async_stream::stream! {}` streams
- futures returned by `async {}` blocks (the compiler is lazy)
- self-referencing data structures such as trees

Why are `async {}` futures unsafe to move and `Future` does not have this requirement?

When a future with **self-referencing variables** has been polled and was supended, it should not be moved by anyone anymore to prevent invalidation.

<!-- end_slide -->

### Immoveable async blocks

Local variables in `async {}` blocks may reference each-other ahead of an `await` point.

```rust
async {
    let a = 1;
    let r = &a;
    sleep().await;
    println!("After wake-up r = {r}");
}
```

This block is converted into an `enum` with a code-generated transition function.

Each variant of the `enum` is a phase in the `async` block, before or after an `await` point.

Each phase contains all local variables in the phase. 

If the local variables reference eachother, 

- the type of this variant of the `enum` is self-referencing (unmoveable) or `!Unpin`
- the `enum` itself is unmoveable
- the `impl Future` does not convey the message that the underlying `enum` is unmoveable.
- we always need to use `impl Future + Unpin` when using this future in an executor.


<!-- end_slide -->


### Streams as a kind of futures

Streams are simply a future. But 

- their return type is a future of an option
- the name of the `poll` method is different

Otherwise, streams are identical to futures.

The semi-official definition in `futures::Stream` is a trait:

```rust
pub trait Stream {
    type Item;

    fn poll_next(
        self: Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<Option<Self::Item>>;
}
```


<!-- end_slide -->

## Streams and coroutines


More theoretical chapter.

- What is a coroutine?
- What is the relationship between streams and coroutines?

<!-- end_slide -->

### Coroutine as a concept

Normal functions just take input and return output (immediately).

**Coroutines** are functions that can be suspended.

1. Upon being suspended a coroutine **yields a value**.
2. Then the caller can continue with other functions.
3. Later the caller may decide to resume the suspended coroutine with resumption data input
4. If the coroutine ends, it returns (not yield) a final value 

**Important**: the `Coroutine` trait in Rust is unstable.

<!-- end_slide -->

### Coroutines in nightly Rust

The trait definition is a super-set of `Future`:

```rust
pub trait Coroutine<R = ()> {
    type Yield;
    type Return;

    fn resume(
        self: Pin<&mut Self>,
        arg: R,
    ) -> CoroutineState<Self::Yield, Self::Return>;
}
```

Notice the `R` stands for `Resume`, is a type generic and is different from `Coroutine::Return`. 

This means that one same type may behave as different coroutines depending on the resume input, but can only have one `Return` type.

<!-- end_slide -->

### Example of Rust coroutin


The following coroutine (in nightly Rust) has resume data type `R = ()`:

```rust
let mut coroutine = #[coroutine] || {
    yield 1;
    "foo"
};

match Pin::new(&mut coroutine).resume(()) {
    CoroutineState::Yielded(1) => {}
    _ => panic!("unexpected return from resume"),
}
match Pin::new(&mut coroutine).resume(()) {
    CoroutineState::Complete("foo") => {}
    _ => panic!("unexpected return from resume"),
}
```


<!-- end_slide -->

### Streams as a type of coroutine

We can classify everything seen in this presentation up until now:

|          | _YIELDS_      | _RESUMES_ | _RETURNS_     |
| -------- | ------------- | --------- | ------------- |
| ITERATOR | option        | !         | !             |
| FUTURE   | ()            | waker     | future output |
| STREAM   | future option | waker     | !             |

Remark: `GEN` stands for Rust `gen` blocks. In general, in other languages, generators can also return values.

Table inspired by [post by without.boats](https://without.boats/blog/poll-next/).

<!-- end_slide -->

### Synchronous vs. asynchronous things

Coroutines are part of a bigger classification of functions.

Synchronous functions:

|                      | _TAKES_ | _CAPTURES_ | _YIELDS_ | _RESUMES_ | _RETURNS_ |
| -------------------- | ------- | ---------- | -------- | --------- | --------- |
| Imperative `loop {}` | !       | !          | !        | !         | !         |
| Blocks `{}`          | !       | captured   | !        | !         | output    |
| Function items `fn`  | input   | !          | !        | !         | output    |
| Closures `Fn`        | input   | captured   | !        | !         | output    |
| `Iterator`           | !       | !          | option   | !         | !         |
| `#[coroutine]`       | input   | !          | item     | any       | any       |

Asynchronous functions:

|                    | _TAKES_ | _CAPTURES_ | _YIELDS_      | _RESUMES_ | _RETURNS_     |
| ------------------ | ------- | ---------- | ------------- | --------- | ------------- |
| `Future`           | !       | !          | ()            | waker     | future output |
| `async {}`         | !       | `'static`  | ()            | waker     | future output |
| Closures `AsyncFn` | input   | captured   | !             | !         | future output |
| `Stream`           | !       | !          | future option | waker     | !             |


<!-- end_slide -->

## Advanced stream creation

We will now look on how to create useful stream combinators that help to write functional/declarative async code.

- Simplest stream from future.
- General approach for combinators
- Example of stream combinator

<!-- end_slide -->

### Stupid example: `Future -> Stream`

Every future can be converted into a stream by return `Some(Fut::Output)` once:

```rust
pub struct Once<Fut> {
    future: Option<Fut>
}

impl<Fut: Future> Stream for Once<Fut> {
  type Item = Fut::Output;

  fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
      let mut this = self.project();
      let v = match this.future.as_mut().as_pin_mut() {
          Some(fut) => ready!(fut.poll(cx)),
          None => return Poll::Ready(None),
      };
      this.future.set(None);
      Poll::Ready(Some(v))
  }
}
```


<!-- end_slide -->

### How is `futures::Map` implemented?

One of the simplest stream combinators is in the semi-standard library `futures`.

It is used to map a stream to a new stream by mapping each value.

```rust
pub struct Map<St, F> {
    #[pin]
    stream: St,
    f: F,
}

impl<St, F> Stream for Map<St, F>
where
    St: Stream,
    F: FnMut1<St::Item>,
{
    type Item = F::Output;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let mut this = self.project();
        let res = ready!(this.stream.as_mut().poll_next(cx));
        Poll::Ready(res.map(|x| this.f.call_mut(x)))
    }
}
```

The `#[pin]` attribute implements a method `Pin<&mut Map> -> Pin<&mut St>`.

It **projects** the pinned mutable reference to a pinned reference to the inner stream.

This macro uses `unsafe` and assumes the writer knows which fields are realy `Unpin` / safe-to-move. **Not recommended.**

You can also declare a field of type `Pin<Box<<Stream>>` and forget about the macro.

<https://docs.rs/futures/latest/futures/stream/struct.Map.html>

<!-- end_slide -->

### Aggregated declarative stream combinators

Usually when you create an aggregate stream, you have to follow these steps:

1. Convert high-level functional description into a stream state object
2. Come up with a method that updates the stream state
3. Implement the `Stream::poll_next` method using 
  - First **project the pins** that you need into mutable references
  - Reconstruct pins from the mutable references of the parts
  - Pass-through to the `poll_next` or `poll` methods of underlying futures
  - call the previously mutable state update method

Often you can put most of your logic in the state update method.

Do not forget to store the waker in case the underlying input data types are not only based on futures. The waker needs to be stored near a place where the IO-bound operation completes. (Most of the time this is not needed.)

<!-- end_slide -->


### Aggregation examples: flattening nested streams


The `futures` crate provides flatten functions for `Stream<Item: Stream>`:

- sequentially `futures::StreamExt::flatten`
- concurrently `futures::StreamExt::flatten_unordered(None)`

When you are looking for these functions, you are probably doing something nasty. There will often be a simpler approach to the underlying problem.

You can also implement your own aggregated streams.

One type of stream aggregator that I couldn't find is a `forgetful` nested Stream.

I implemented my own with `forgetful_flatten`, it rolls out nested streams and drops previous stream when a new stream arrives on the outer stream.


<!-- end_slide -->

### Aggregation examples: monitoring streams

The `tokio_stream` crate provides [`StreamMap`](https://docs.rs/tokio-stream/latest/tokio_stream/struct.StreamMap.html)

However, I need some more logic and created `merge_check_initialized`.

It monitors whether the required streams have yielded an initial value yet

TODO: discuss implementation