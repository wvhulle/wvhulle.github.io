+++
title = "CLI tools"
description = "List of my favourite command-line tools."
weight = 1
[taxonomies]
tags = ["Linux", "shell", "tool", "command-line"]
+++

## Day-to-day tasks

### Zoxide

Link: [Zoxide](https://github.com/ajeetdsouza/zoxide)

An extension of the essential `cd`. It adds fuzzy folder name matching for your local filesystem. It uses you shell history to learn to jump to the right location.

For example, I have a folder `~/.config/nixos` and don't want to type the whole path (more than once). I can just write `z nixos` and it will jump directly to the nested directory.

You can write more complex queries as well and configure your shell to point `cd` to `z` to replace `cd` completely.

### DirEnv

Link: [Direnv](https://direnv.net/)

Scaffold system environments by just entering and exiting directories. In combination with Nix or other declarative package managers, only the packages you need are available within your projects.

### Zellij

Link: [Zellij](https://zellij.dev/)

Easy terminal splitting. Detaching from views is possible to keep processes running in the background, you can re-attach later.

### OhMyPosh

Link: [Oh-My-Posh](https://ohmyposh.dev/)

Oh-My-Posh gives any shell a more meaningful shell prompt. It can display all kinds of system information such as:

- Compiler toolchain versions for many languages
- Battery state, command duration, ...

You don't have to build the prompt from scratch with individual data entries. Use one of the existing themes. My current them is a minimal one: 'zash'.

### Typos

Spell-checker for source-code that knows how to parse language grammers and adapt spell-checking rules accordingly. It's main goal is to have a low amount of false negatives and being fast.

The most popular spell-checker in VS Code (based on cSpell), does not support language grammars and has too many false negatives.

## Development tasks

### Delta pager

Link: [Delta](https://github.com/dandavison/delta)

An extension of the `diff` command that adds syntax highlighting (for most programming languages) and paging (no need to pipe into `less` / `more`).

You can configure it as the default diff tool for Git. In your `~/.gitconfig`:

```conf
[core]
pager = delta
```

### Helix editor

Link: [Helix](https://helix-editor.com/)

This terminal editor has intuitive and powerful keybindings that are suitable for beginners. It has a built-in fuzzy command and file search dialog.

It requires much less (or no) language server configuration. Most languages have syntax highlighting and basic linting support out of the box (provided the language server is installed as a system dependency).

My favourite keybindings:

- SPACE -> F: Fuzzy file-name search
- SPACE -> E: Folder browser
- gd: Goto definition
- CTRL-o: Jump back (conflicts with Zellij)

To avoid problems with Zellij, you have to lock Zellij with CTRL-g before trying to jump back with CTRL-o.

### Bat

Link: [Bat](https://github.com/sharkdp/bat)

A replacement for `cat` that adds paging (so you don't have to pipe it through `less`), syntax highlighting, and line numbers.

I don't recommend turning this into a shell alias for the standard Linux command  `cat`. It may break other tools like `claude-code` that expect a `cat` that works in a non-interactive shell.

### RipGrep

Link: [Ripgrep](https://github.com/BurntSushi/ripgrep)

Recursively search your current directory for a string or regex pattern, ignoring git-ignored and hidden files. Case insenstive search: `rg -i`.

### GH CLI

Link: [Github CLI](https://cli.github.com/)

With `gh` you can manage PRs from the terminal. A frequent problem I have is that I forget if my branch got merged already. You can see this right away with: `gh pr view`.

Most of the commands have a `--web` option that will automatically open the relevant page in your default web browser. For example, `gh repo view --web` will go to the main view of the current repository.
