+++
title = "Shell"
description = "List of favourite command-line tools."
weight = 1
[taxonomies]
tags = ["Linux", "shell", "prompt", "Rust"]
+++



## [Zoxide](https://github.com/ajeetdsouza/zoxide)

An extension of the essential `cd`. It adds fuzzy folder name matching for your local filesystem. It uses you shell history to learn to jump to the right location.

For example, I have a folder `~/.config/nixos` and don't want to type the whole path (more than once). I can just write `z nixos` and it will jump directly to the nested directory.

You can write more complex queries as well and configure your shell to point `cd` to `z` to replace `cd` completely.

## [Delta](https://github.com/dandavison/delta)

An extension of the `diff` command that adds syntax highlighting (for most programming languages) and paging (no need to pipe into `less` / `more`).

You can configure it as the default diff tool for Git. In your `~/.gitconfig`:

```
[core]
pager = delta
```


## Git difftool

You can configure external tools in `git`, called 'difftools' that improve the default diff-viewing experience. My favourite difftool is [`meld`](https://meldmerge.org/). You can configure it in `git` as the default difftool. In
 `~/.gitconfig`

```
[diff]
tool = meld

[difftool.meld]
cmd = meld "$LOCAL" "$REMOTE"
```

To launch a window comparing the whole repository at different points in time, use something like (`-d` stands for directory compare):

- `git difftool -d [COMMIT_LEFT]..[COMMIT_RIGHT]`
- `git difftool -d [OTHER_COMMIT]`

I recommend going into the settings of `meld` to turn on syntax highlighting.

You can also add it as a `git` alias

```
[alias]
meld=!git difftool -t meld --dir-diff
```

Now, you just have to write: `git meld [BRANCH]` to compare the current branch with another branch.

## [Nushell](https://www.nushell.sh/)

Bash scripts are difficult to write and maintain, because of old-fashioned syntax and a lack of modern features. Frequently, Bash itself does not support certain crucial programming operations.

For example, you have to crawl the web for info on how to use `jq` to extract a basic value from an API. It almost feels like playing "Dungeons and Dragons".

Nushell alleviates the pains of frustrated Bash scripters:

- It has modern programming language features.
- You can still pipe as much as you want.
- Most commands stay the same.

In general you don't need to alias commands as much in Nushell:

- Nushell has an `rm` command that can be configured to delete files to the trash always. Don't search for an external 'safe-delete' `rm` command, it's already part of Nushell core.
- It also has an `ls` command that can be queried using a kind of SQL syntax with traditional pipes.


## Audio notifications

Do you start long-running commands and forget to follow-up on them? The visual / audio bell of `konsole` was not so reliable for me. Instead, I figured out a way to do it within Nushell.

You can define a function in your Nushell config at `~/.config/nushell/config.nu` and add it as `pre_prompt` hook:

```bash
def notify-long-command [] {
  const NOTIFICATION_THRESHOLD = 30sec
  const SOUND_FILE = "/run/current-system/sw/share/sounds/freedesktop/stereo/bell.oga"

  let cmd_duration = (($env.CMD_DURATION_MS? | default "0") | into int | into duration -u ms)

  if $cmd_duration > $NOTIFICATION_THRESHOLD {
    try { ^pw-play $SOUND_FILE } catch { ^paplay $SOUND_FILE }
  }
}

$env.config = (
  $env.config | merge {
    hooks: {
      pre_prompt: [
        {||
          notify-long-command
        }
      ]
    }
  }
)
```

Notice that Nushell has a 'duration' type like Rust. Tweak the parameters as you wish. Maybe you can find out a way to modify the sound based on metadata about the previous command?

## [Helix](https://helix-editor.com/)

This terminal editor has intuitive and powerful keybindings that are suitable for beginners. It has a built-in fuzzy command and file search dialog.

It requires much less (or no) language server configuration. Most languages have syntax highlighting and basic linting support out of the box (provided the language server is installed as a system dependency).

My favourite keybindings:

- SPACE -> F: Fuzzy file-name search
- SPACE -> E: Folder browser
- gd: Goto definition
- CTRL-o: Jump back (conflicts with Zellij)

To avoid problems with Zellij, you have to lock Zellij with CTRL-g before trying to jump back with CTRL-o.

## [Atuin](https://atuin.sh/)

Interactive search / recommendation / sync system for your shell history.

First time setup:
1. Register: atuin register -u USERNAME -e EMAIL
2. Choose password
3. Display encryption key: atuin key
4. Save key in password manager
5. Sync: atuin sync

Second machine
1. Login: atuin login
2. Enter USERNAME, PASSWORD
3. Enter encryption key from first machine
4. Sync: atuin sync

If problems:
1. Remove account: atuin account delete
2. Remove local data in `~/.local/share/atuin`

Beware: By default it hijacks your upper arrow key to suggest commands from your history. However, you can make it narrow down to commands within the same Git repository or folder.

## [Oh-My-Posh](https://ohmyposh.dev/)

The default prompt of my Bash shell looks like this:

```
[wvhulle@x1:~]$
```

The default Nushell prompt is

```
/root>                        26-08-25 07:58:58
```

The default `fish` shell prompt is slightly better and shows the `git` branch (if any) in the current directory.

Oh-My-Posh gives any shell a more meaninful shell prompt. It can display all kinds of system information such as:

- Compiler toolchain versions for many languages
- Battery state, command duration, ...


You don't have to build the prompt from scratch with individual data entries. Use one of the existing themes. My current them is a minimal one: 'zash'.


## [Bat](https://github.com/sharkdp/bat)

A replacement for `cat` that adds paging (so you don't have to pipe it through `less`), syntax highlighting, and line numbers.

I don't recommend turning this into a shell alias for the standard Linux command  `cat`. It may break other tools like `claude-code` that expect a `cat` that works in a non-interactive shell.

## [Direnv](https://direnv.net/)

Scaffold system environments by just entering and exiting directories. In combination with Nix or other declarative package managers, only the packages you need are available within your projects.

## [Zellij](https://zellij.dev/)

Easy terminal splitting. Detaching from views is possible to keep processes running in the background, you can re-attach later.

## [Claude-code](https://docs.anthropic.com/en/docs/claude-code)

A chat agent that has access to your filesystem and system commands. It sends all your local data (file contents, command output) to remote Anthropic servers, so be careful.

My favourite prompts:

- Scan the system journal for warnings or errors since the last boot and identify issues that can be resolved according to online bug reports.
- Use NixOS options and home-manager options to state the bug fixes you just made declaratively in `nix` files.
- I made this cool script, package it for distribution X.

## [Ripgrep](https://github.com/BurntSushi/ripgrep)

Recursively search your current directory for a string or regex pattern, ignoring git-ignored and hidden files. Case insenstive search: `rg -i`.

## [Github CLI](https://cli.github.com/)

With `gh` you can manage PRs from the terminal. A frequent problem I have is that I forget if my branch got merged already. You can see this right away with: `gh pr view`.

Most of the commands have a `--web` option that will automatically open the relevant page in your default web browser. For example, `gh repo view --web` will go to the main view of the current repository.

## [Carapace](https://carapace.sh/)

Aggregator for a useful, broad set of shell-completers. Can even complete online GitHub repositories. Integrates with most shells.

In Nushell, you can combine zoxide completions with carapace using this in your `~/.config/nushell/config.nu`:

```bash
let external_completer = {|spans|
  match $spans.0 {
    z|zi => {
      $spans | skip 1 | zoxide query -l ...$in | lines | where {|x| $x != $env.PWD }
    }
    _ => {
      carapace $spans.0 nushell ...$spans | from json
    }
  }
}

$env.config = (
  $env.config | merge {
    completions: {
      external: {
        enable: true
        completer: $external_completer
      }
    }
  }
)
```

## Typos

Spell-checker for source-code that knows how to parse language grammers and adapt spell-checking rules accordingly. It's main goal is to have a low amount of false negatives and being fast.

The most popular spell-checker in VS Code (based on cSpell), does not support language grammars and has too many false negatives.

## [NCDU](https://dev.yorhel.nl/ncdu)

Analyze which folders use the most disk space.

## [Powertop](https://01.org/powertop/)

See how many Watts your system is using and which processes are consuming the most power.

Use it to create custom "power profiles" with `power-profiles-daemon`.

You can use a Bash script that listens for user events (like sliding the power profile slider from 'balanced' to 'performance'):

```bash
#!/usr/bin/env bash

dbus-monitor --system "type='signal',interface='org.freedesktop.UPower.PowerProfiles'" | while read -r line; do
  if echo "$line" | grep -q "ActiveProfile"; then
    # Get current profile
    PROFILE=$(powerprofilesctl get 2>/dev/null || echo "balanced")
    # Call the power profile handler
    handler.sh "$PROFILE"
  fi
done
```

Then you just have to implement `handler.sh` to apply the right settings to your CPU and other power-consuming peripherals.


## Wluma

Adjusts your screen and keyboard brightness according to learned preferences. Everytime you adjust the brightness manually and `wluma` is running, it uses this information to adjust the brightness the next day around this time.

You can also use the webcam instead, but this might result in an LED flickering every 5 seconds.

For internal screens, like laptop screens, `wluma` works with minimal configuration. For external screens, you might need a Linux kernel module `ddcii-driver`, udev rules and maybe even create a i2c device.

## AWatcher & ActivityWatch

ActivityWatch is an open-source local time tracking server with a web-frontend.Because it is local, you don't have to worry about companies selling your usage data. It is essential to add client programs that harvest the data and send it to the local server.

Using hierarchical window title pattern matching rules you can keep track of:


- How many hours for each client / project a week.
- Total screen time, over the past year.


It took me a while to figure out which client programs are actually necessary. On Wayland, you need to use `awatcher` to monitor desktop window titles and run it immediately after login (using autostart or a user service). Running it twice will result in errors.

Some user programs like Firefox and VS Code have ActivityWatch extensions that can provide more fine-grained usage data.


## [Geekbench](https://www.geekbench.com/)

When you want to make a choice between different computer systems, you may want to benchmark them against eachother. I found the (closed-source) Geekbench test suites quite easy to use. They exist for all operating systems and are packaged for most Linux distributions.

After installation, you can just run one of the `geekbench` commands (based on your CPU architecture). The results are uploaded to Geekbench servers and displayed in a web interface.

You can directly save results to your account, which is useful if you want to monitor for performance regressions on your machines.
