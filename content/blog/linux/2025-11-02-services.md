+++
title = "Services"
description = "List of my favourite services that run in the background."
weight = 2
[taxonomies]
tags = ["Linux", "synchronisation", "SystemD", "web", "service"]
+++


## NixOS

It's more than just a service, it's a whole operating system. But it is **great for my memory issues**. I used forget every solution I created for my Linux problems, but with Nix I don't have to remember each solution anymore. I can write operating system solutions as code and track different versions in Git.

## Atuin history sync

Link: [Atuin](https://atuin.sh/)

Interactive search / recommendation / sync system for your shell history.

First time setup:

1. Register: `atuin register -u USERNAME -e EMAIL`
2. Choose password
3. Display encryption key: `atuin key`
4. Save key in password manager
5. Sync: `atuin sync`

Second machine

1. Login: `atuin login`
2. Enter USERNAME, PASSWORD
3. Enter encryption key from first machine
4. Sync: `atuin sync`

If problems:

1. Remove account: `atuin account delete`
2. Remove local data in `~/.local/share/atuin`

Beware: By default it hijacks your upper arrow key to suggest commands from your history. However, you can make it narrow down to commands within the same Git repository or folder.

## PowerTop

Link: [Powertop](https://01.org/powertop/)

See how many Watts your system is using and which processes are consuming the most power.

Use it to create custom "power profiles" with `power-profiles-daemon`.

You can use a script that listens for user events (like sliding the power profile slider from 'balanced' to 'performance'). Here is a Nu script that listens on D-Bus for power profile event switches and triggers different power configurations (not my best Nu):

<details>
<summary>Click to view power profile monitor script </summary>

```bash
#!/usr/bin/env nu

# Power profile monitor script
# This script monitors D-Bus for power profile changes and triggers the handler
# Optimized for low power consumption

# Monitor power profile changes and trigger handler when profile changes
def main [
  handler_path: string # Path to the power profile handler script
] {
  print "<6>Starting power profile monitor..."
  print $"<7>Handler path: ($handler_path)"

  mut last_profile = ""

  # Try to get initial profile
  let initial_profile = (
    try {
      ^powerprofilesctl get | complete | get stdout | str trim
    } catch {
      print "<4>Warning: Could not get initial power profile, defaulting to balanced"
      "balanced"
    }
  )

  print $"<6>Initial power profile: ($initial_profile)"
  $last_profile = $initial_profile

  # Use for loop instead of each to allow mutable variable modification
  print "<6>Monitoring D-Bus for power profile changes..."
  for signal in (
    ^dbus-monitor --system "type='signal',interface='org.freedesktop.UPower.PowerProfiles'"
    | lines
    | where $it =~ "ActiveProfile"
  ) {
    # Add small delay to debounce rapid changes
    sleep 500ms

    # Get current profile
    let profile = (
      try {
        ^powerprofilesctl get | complete | get stdout | str trim
      } catch {|err|
        print $"<4>Warning: Could not get power profile: ($err.msg), using balanced"
        "balanced"
      }
    )

    # Only call handler if profile changed
    if $profile != $last_profile {
      print $"<6>Profile changed from '($last_profile)' to '($profile)'"

      try {
        let result = (^$handler_path $profile | complete)
        if $result.exit_code != 0 {
          print $"<3>Error: Handler exited with code ($result.exit_code)"
          print $"<7>Stderr: ($result.stderr)"
        } else {
          print "<7>Handler executed successfully"
        }
      } catch {|err|
        print $"<3>Error calling handler: ($err.msg)"
      }

      $last_profile = $profile
    }
  }
}
```

</details>

## Wluma

Adjusts your screen and keyboard brightness according to learned preferences. Everytime you adjust the brightness manually and `wluma` is running, it uses this information to adjust the brightness the next day around this time.

You can also use the webcam instead, but this might result in an LED flickering every 5 seconds.

For internal screens, like laptop screens, `wluma` works with minimal configuration. For external screens, you might need a Linux kernel module `ddcii-driver`, udev rules and maybe even create a i2c device.
