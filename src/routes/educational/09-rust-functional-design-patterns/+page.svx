# Functional design patterns

Previous lecture: [functional programming](/educational/07-rust-functional-programming)

See:

- Advanced functional programming concepts often come from category theory. See[fantasy-land](https://github.com/fantasyland/fantasy-land)

Functional programming (FP) has several design patterns and concepts that differ from those typically found in object-oriented programming (OOP). While OOP design patterns focus on object relationships and communication, FP patterns emphasize stateless computation and transformations. Some FP design concepts that stand out as distinctly different or new compared to OOP include:

## 1. Function Composition

It is possible to build complex functions by composing simpler ones, each performing a discrete operation. Functions do not have side effects by default. A side effect is something that happens outside the body of a function. This is enabled by disallowing shared state.

### Example

A method is a kind of function that works on a class. It is called by writing the instance of of the class, a dot and then the name of the function.

An iterator is a data structure that is used to iterate over a structure. Rust provides powerful iterator methods which can be chained together to perform complex operations in a clear and elegant manner. Here's an example that demonstrates this:

Imagine we have a list of `Person` structs, and we want to find the names of all people who are over 18 years old, sort those names, and then collect them into a vector.

```rust
struct Person {
    name: String,
    age: u8,
}

fn main() {
    let people = vec![
        Person { name: "Alice".to_string(), age: 30 },
        Person { name: "Bob".to_string(), age: 20 },
        Person { name: "Charlie".to_string(), age: 17 },
        Person { name: "Dave".to_string(), age: 23 },
    ];

    let adult_names: Vec<String> = people.iter()
        .filter(|p| p.age > 18)
        .map(|p| p.name.clone())
        .collect()

    println!("Adults: {:?}", adult_names);
}
```

Let's break down the method chaining above:

- `.iter()` creates an iterator over the `people` vector.
- `.filter(|p| p.age > 18)` filters out the `Person` instances that do not meet the condition (i.e., being older than 18).
- `.map(|p| p.name.clone())` transforms the iterator from `Person` instances to their associated `name` strings.
- `.collect()` collects the transformed values into a `Vec<String>`.
- with the addition of `sort()`, we collect the adults' names and then

Method chaining allows for such transformations to be expressed succinctly, making the code both elegant and readable.

### Another example

The `tidyverse` in R is a collection of packages designed for data science that share an underlying design philosophy. Function composition in `tidyverse` is often achieved using the `%>%` operator from the `magrittr` package, which allows for clear and readable chaining of functions. Below is an example of a data manipulation sequence on a hypothetical `data.frame` called `df`.

Let's assume you want to:

1. Select certain columns,
2. Filter rows based on some condition,
3. Summarize the data with some aggregation, and
4. Arrange the results.

Hereâ€™s how this might look using `dplyr`, which is part of the `tidyverse`:

```r
library(tidyverse)

# Assuming df is your data.frame with columns: id, category, and value

result <- df %>%
  select(id, category, value) %>%   # Select only the columns you're interested in
  filter(value > 10) %>%            # Filter rows where 'value' is greater than 10
  group_by(category) %>%            # Group data by 'category' column
  summarize(
    mean_value = mean(value),       # Calculate the mean of 'value' for each group
    max_value = max(value)          # Find the max 'value' for each group
  ) %>%
  arrange(desc(mean_value))         # Arrange the summarized result by 'mean_value' descending

print(result)
```

By chaining these function calls, `tidyverse` lets you write data transformations in a way that is both functional and readable. Each stage of the transformation is clear, and the overall process reads almost like a sentence describing what you want to do with the data.

## 2. Monads

**Concept:** Monads wrap and handle values within a context (like error handling, state representation), providing mechanisms for chaining operations in a safe way.

A monad is like a container for a dirty computation with side effects. When using a monad, you declare what is

- core to the algorithm and has computational value
- you declare what happens when an operation fails

### Biology Example in Rust

```rust
use std::result;

fn analyze_sample(sample: BloodSample) -> result::Result<DNASequence, AnalysisError> {
    // Analyze the blood sample and extract DNA sequence.
    if sequence.len > 0 {
        Ok(sequence)
    } else {
        Err(error)
    }
}
```

Strictly speaking, a monad is a type constructor which takes an underlying type and puts it into a specific computational context. For example, Maybe or Option types for dealing with optional values, List for non-deterministic computations, or IO for input/output operations.

In this example, `Result` is a monad in Rust that handles errors during function chaining and it's constructor is `Ok` in the case of success or `Err` in the case of an error.

```rust
fn replicate_sequence(sequence: DNASequence) -> result::Result<Vec<DNASequence>, ReplicationError> {
    // Replicate the given DNA sequence.
}

// Using `and_then` to chain operations using monadic behavior
let result = analyze_sample(sample).and_then(replicate_sequence);
```

The last function is a bind function. This function takes a monadic value and a function that transforms the underlying plain value, then yields a new monadic value. The key here is that the transformation function also returns a result in a monadic context, allowing the actions to be chained together

## 3. Currying and Partial Application

**Concept:** Breaking down a function that takes multiple arguments into a series of functions each taking a single argument.

**Biology Example in Rust:**

```rust
fn add_nutrient(nutrient: Nutrient) -> Box<dyn Fn(Environment) -> Environment> {
    Box::new(move |mut environment: Environment| {
        environment.add(nutrient.clone());
        environment
    })
}

let enriched_environment = add_nutrient(Nutrient::Nitrogen)(initial_environment);
```

`add_nutrient` partially applies the function by fixing the nutrient parameter and returning a new function.

## 4. Algebraic Data Types (ADTs)

**Concept:** Composing types via "sums" (e.g., enums, which provide a way to define a type by enumerating its possible variants) and "products" (e.g., structs, which bundle several values together).

**Biology Example in Rust:**

```rust
enum CellState {
    Alive,
    Dead,
    Dormant,
}

struct Cell {
    state: CellState,
    energy_level: u32,
}

fn check_cell_state(cell: &Cell) -> CellState {
    match cell.state {
        CellState::Alive if cell.energy_level > 10 => CellState::Alive,
        _ => CellState::Dead,
    }
}
```

Using sum types (`enums`) and product types (`structs`), we model cell states and behaviors comprehensively.

These FP concepts bring a different approach to software design compared to OOP, often leading to more predictable and maintainable code, especially in systems where functions can elegantly express domain logic, like in modeling biological processes. Rust, as a language that supports both FP and OOP paradigms, allows developers to use these concepts effectively, providing robustness and flexibility in design choices.
