# Object-Oriented Programming

Existing literature:

- [Object-Oriented Python](https://www.oreilly.com/library/view/object-oriented-python/9781098129842/)

## Introduction

Object oriented programming started around 1960 and was named by Alan Kay. Object-Oriented Programming is an intuitive way of structuring your code by mirroring real-world systems. Imagine being able to define:

- organisms,
- molecules,
- ecosystems

that behave much like their physical counterparts, complete with individual characteristics and abilities. Object-oriented programming enables this by providing building blocks for building accurate models of physical systems.


## Classes and Objects

Classes: Think of classes as templates for creating your objects. Classes contain public or private methods which are function definitions for associated operations.

Objects: These are specific instances of classes - like individual animals created from the same blueprint, each with its own state. For a mathematician, like me, everything in the world is an object of some class. This got me into troubles already. 

### Example in Python

A `Cell` class might encapsulate the complexity of a biological cell while exposing methods to trigger mitosis, apoptosis, or to alter chemical concentrations within the cell.

```python
class Cell:
    def __init__(self, dna: str):
        self.dna = dna
        self.proteins = ["Hemoglobin", "Insulin"]

    def mitosis(self):
        # Logic for cell division

    def apoptosis(self):
        # Logic for programmed cell death

    def replicate_dna(self):
        return self.dna * 2  # Method to interact with the encapsulated attribute

# Usage:
cell = Cell("ATCG")
cell.mitosis()  # Public interface to initiate cell division
```




#### Attributes

Objects can contain both data and code such as for example a property called DNA which stands for some data representing the sequence. This data is also called **attributes** of the object. Private attributes can only be used by the object itself. Attributes represent the **internal state** of an object and may change throughout the life-time of an object. Attributes can be both private and public.

#### Methods

Objects also contain code, for example a cell object can contain the method `mitosis`. All methods are functions that take the `self` or `this` argument. Methods are not really part of the object. They are shared between objects of the same class. Methods are functions, so they can take type hints. 

Methods can be public and private. Private methods can only be referenced inside other methods of the same class.

The `__init__` method is not really a method but a special function. It is the constructor of the class and produces  an instance of a class. It takes some initial data as arguments.

#### Type Hints

It is recommended to use type hints, because they prevent errors by imposing constraints on the way your function can be used. One way to enforce type hints, is by using tools like "mypy" and "pylint" in Python. Ask for help on how to setup.


### Example in C++

Below is an example of a C++ class with a constructor.
```cpp
#include <string>
#include <ostream>
#include <iostream>

class Car {
private:
    std::string make;
    std::string model;
    int year;

public:
    // Constructor with an initializer list to initialize the data members
    Car(const std::string& make, const std::string& model, int year)
        : make(make), model(model), year(year) {
    }

    // Example method to display car information
    void displayInfo() const {
       std::cout << "Make: " << make << ", Model: " << model << ", Year: " << year << std::endl;
    }
};


```

This class, `Car`, has a constructor that initializes the car's make, model, and year.
In the constructor of the `Car` class, an initializer list is used:

```cpp
Car(const std::string& make, const std::string& model, int year)
    : make(make), model(model), year(year) {
}
```

The line `: make(make), model(model), year(year)` uses an initializer list to initialize the member variables of the class with the values passed to the constructor. This is a common practice in C++ for several reasons, including efficiency and clarity.

Here's what's happening:

- `make(make)` initializes the member variable `make` with the value of the constructor parameter `make`.
- `model(model)` initializes the member variable `model` with the value of the constructor parameter `model`.
- `year(year)` initializes the member variable `year` with the value of the constructor parameter `year`.

In this context, the names within the parentheses refer to the parameters passed to the constructor, while the names before the parentheses refer to the class's member variables. Since they have the same name, we can distinguish between them because the context of an initializer list clearly indicates that the left-hand side of each initialization refers to the class members.




```cpp
// The usage of the constructor would be like this:
int main() {
    Car myCar("Toyota", "Corolla", 2020);
    myCar.displayInfo();
    return 0;
}
```

In the `main` function, we create an object of `Car` called `myCar`. The constructor for `Car` is called with the arguments `"Toyota"`, `"Corolla"`, and `2020` to initialize the `make`, `model`, and `year` of the car, respectively. 




## 1. Encapsulation

Encapsulation is about maintaining an object's state private inside a class and providing access only through public methods.

In the previous example a cell encapsulates literally and philosophically speaking the sequence data and related functions. No other objects have this data or function. The cell is one unit or encapsulation.

It is possible to encapsulate too much state and make you classes too complex. There is the following rule:

### The Single-responsibility principle

Robert C. Martin:

> "There should never be more than one reason for a class to change."

In other words, every class should have only one responsibility. Alternative explanation: Gather together the things that change for the same reasons. Separate those things that change for different reasons

## 2. Abstraction

Abstraction means hiding the detailed implementation and showing only the necessary features of an object. 

### Classes as abstraction

A class is a form of abstraction. You use a class to represent a certain number objects that share something in common, without showing the objects itself.

### Interfaces

It is possible to define another layer of abstraction on top of a class, called an abstract class. In other languages this is called an **interface** or trait. An interface is the opposite of an implementation. An implementation provides functionality by giving concrete implementations.

### Example in Python

An `Organism` abstraction might define methods like `eat()`, `sleep()`, and `reproduce()`, regardless of whether the organism is a plant, animal, or bacteria. Specific organisms would implement these in diverse ways.

In Python, ABC stands for **abstract base class**. It represent an abstract class, which is another name for an interface.

```python
from abc import ABC, abstractmethod

class Organism(ABC):

    @abstractmethod
    def eat(self):
        pass

    @abstractmethod
    def sleep(self):
        pass

    @abstractmethod
    def reproduce(self):
        pass
```

In C++, this would become

```cpp
#include <iostream>

using namespace std;

class Organism {
public:
    virtual void eat() = 0;
    virtual void sleep() = 0;
    virtual void reproduce() = 0;
};
```




Below are concrete implementations for different types of organisms extending the `Organism` abstract base class. Each subclass provides its own version of the `eat`, `sleep`, and `reproduce` methods:

```python
class Plant(Organism):

    def eat(self):
        print("Plant is photosynthesizing.")

    def sleep(self):
        print("Plant enters a state of lower metabolic activity at night.")

    def reproduce(self):
        print("Plant releases seeds into the environment.")


class Animal(Organism):

    def eat(self):
        print("Animal is hunting for food.")

    def sleep(self):
        print("Animal is sleeping to restore energy.")

    def reproduce(self):
        print("Animal finds a mate for reproduction.")


class Bacterium(Organism):

    def eat(self):
        print("Bacterium absorbs nutrients from its surroundings.")

    def sleep(self):
        # Many bacteria do not have sleep cycles as eukaryotes do
        # But they can enter dormant states, which we'll call 'sleep' here for simplicity
        print("Bacterium enters a dormant state.")

    def reproduce(self):
        print("Bacterium reproduces via binary fission.")
```

With these implementations, each subclass of `Organism` now behaves according to its biological characteristics:

```python
# Usage example:
plant = Plant()
animal = Animal()
bacterium = Bacterium()

plant.eat()  # Plant is photosynthesizing.
animal.sleep()  # Animal is sleeping to restore energy.
bacterium.reproduce()  # Bacterium reproduces via binary fission.
```

The type hints in the original `Organism` class ensure that any further subclasses must implement `eat`, `sleep`, and `reproduce` methods if they are to be instantiated. This enforces a consistent interface across all organism types.

## 3. Inheritance

Inheritance allows a new class to adopt the behavior and properties of an existing class. According to the OCP, you should be able to extend the behavior of a class without altering its source code. This can be done by creating subclasses that inherit from a base class.

### Example

A specialized `BacterialCell` class might inherit from a more general `Cell` class, gaining basic cellular functions while adding bacterial-specific behaviors.

```python
# Parent class
class Plant:
    def __init__(self, height: float):
        self.height = height

# Child class
class Tree(Plant):
    def __init__(self, height: float, age: float):
        super().__init__(height)
        self.age = age

oak = Tree(100, 80)
print(oak.height)  # Output: 100
```

In this example `Plant` is the super class or parent class of `Tree`. One parent or super class may have multiple child classes. The parent class is a more general version of the child classes which are more constraint.

## 4. Polymorphism

Polymorphism enables one interface to implement different functions. In other words, one function may accept multiple types of classes.


### Example in Python

A function that simulates the response of an organism to a stimulus could operate on any object that implements a `respond_to_stimulus` method, whether it's a plant cell or an animal cell.

```python
def simulate_response(cell: Cell):
    cell.respond_to_stimulus()

class PlantCell(Cell):
    def respond_to_stimulus(self):
        # Plant-specific stimulus response

class AnimalCell(Cell):
    def respond_to_stimulus(self):
        # Animal-specific stimulus response

# Both PlantCell and AnimalCell can be passed to simulate_response
```

Another example with mammals. One class has several child-classes and one function takes the super class as argument.

```python
class Animal:
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return "Woof!"

class Cat(Animal):
    def speak(self):
        return "Meow!"

def animal_sound(animal):
    print(animal.speak())

# Both Dog and Cat are treated as Animal
animal_sound(Dog())  # Output: Woof!
animal_sound(Cat())  # Output: Meow!
```

### Example in C++

Polymorphism in C++ can be demonstrated through the use of inheritance and virtual functions. Here is a simple example illustrating polymorphism with a base class `Shape` and its derived classes `Circle` and `Rectangle`.


The interface or abstract class `Shape` is declared first. Afterwards multiple concrete implementing classes are defined.

```cpp
#include <iostream>
#include <cmath>

// Base class
class Shape {
public:
    // Virtual method for calculating area
    virtual double area() const = 0;

    // Virtual destructor to allow derived class destructors to be called
    virtual ~Shape() {}
};

```

In the following code, `Shape` is an abstract base class that defines a pure virtual function `area()`. `Circle` and `Rectangle` are derived classes that override the `area()` method.

```cpp


// Derived class: Circle
class Circle : public Shape {
private:
    double radius;

public:
    Circle(double r) : radius(r) {}

    // Override the area method to compute the area of a circle
    virtual double area() const override {
        return M_PI * radius * radius;
    }
};

// Derived class: Rectangle
class Rectangle : public Shape {
private:
    double width;
    double height;

public:
    Rectangle(double w, double h) : width(w), height(h) {}

    // Override the area method to compute the area of a rectangle
    virtual double area() const override {
        return width * height;
    }
};


```


Next comes a polymorphic function that takes a reference to a `Shape` and prints out its area. Because it is using a reference to the base class, it will work with any object of a class derived from `Shape`.

```rust
// Function to display the area of a shape
void printArea(const Shape& shape) {
    std::cout << "Area: " << shape.area() << std::endl;
}

int main() {
    Circle circle(5.0);
    Rectangle rectangle(10.0, 2.0);

    // The same function, printArea, can operate on objects of different classes
    // and produce different results based on which class's area method is invoked.
    // This is an example of polymorphism.
    printArea(circle);       // Calls Circle::area
    printArea(rectangle);    // Calls Rectangle::area

    return 0;
}
```

Inside `main`, we create instances of `Circle` and `Rectangle`, then call `printArea` on each. Despite calling the same function, `printArea`, polymorphism allows us to calculate the correct area for each shape due to the virtual dispatch mechanism of C++. The area method appropriate for the actual type of object is called at runtime.


## Summary

Object-oriented programming is a way of programming that includes concepts such as encapsulation, abstraction, inheritance and polymorphism. These OOP principles facilitate the development of modular and maintainable software applications in biological research, which can range from simple bio-informatics tools to complex simulation platforms modeling entire ecosystems or biological processes. By leveraging OOP, developers can create models that mirror the hierarchical and diversified nature of biological entities and systems.

## Practical final remarks

To apply object-oriented programming, you have to make a model of the domain you are working in and understand how it works. A domain is nothing more than people who know what they are doing. So first, you have to look at how people do their work. Usually people will spontaneously tell you what their annoyances are and these are a starting point for object-oriented modelling. 

### Modeling

The next step is modeling data. Which types of objects are there? These will become classes. Are there patterns in usage of the data? These will become methods. 

Once in a while you have look at a higher level and see whether more abstraction is necessary (or unnecessary) and create abstract classes or interfaces. While doing this you have to keep in mind that complexity is your enemy. An abstraction should only be made if it simplifies the bigger picture. Copy-pasting only increases the length and the complexity, so should be avoided at all cost.

### Naming

Throughout the whole process you have give appropriate names to everything. The least amount of surprise is necessary. Names should be as mainstream as possible. Writing code is an act of communication to whoever is reading it in the future. Code is not supposed to be read by machines, it supposed to be read by humans from different backgrounds. That means that code should not be complicated. Code should be as simple as possible. The only target is the speed of consumption by a future reader. A future reader can process the code faster if names are obvious and self-explanatory to new readers, they serve as a way of documentation. Using a modern IDE, it is easy to change and improve names. (In VS Code, you can press f2.)

Next lecture: [object-oriented design patterns](/educational/08-rust-object-design-patterns)
