# Asynchronous programming

Previous lecture: [types](/educational/04-rust-types)

## Situation: Planning execution

Imagine a situation with:

- many computation tasks
- start and end of computations bound externally
- limited amount of time

How to plan execution?

## Solution

One way to solve the problem of executing is:

1. start all tasks at the same time
2. pause computations when blocked by external factor.
3. continue other unblocked computations as much as possible until blocked

In this way, we can finish all computations in order of availability. This is **asynchronous programming**

Asynchronous programming is software programming paradigm that **avoids blocking computation** on *one thread*. Because of this, asynchronous programming is **non-blocking programming**. It can be used with multiple threads or just one thread. It is essentially an abstraction that allows multiple (possibly blocked) computations happen faster as one set.

Asynchronous programming is about optimizing the schedule of computations that can happen in parallel but might each be blocked by separate factors.

## Role of futures

The core piece of asynchronous programming is a `Future`. A **future** is also called a "promise" in JavaScript. A future is a planned, possible finished computation. It carries the possibility of a completed computation.

Examples of futures are:

- The content of a packet at the next moment a network packet arrives
- The buffer content to be read at the next moment a device writes to a COM port

Futures are competing for execution by an execution planner.

## Polling futures

A future is implemented as an object that has a **poll** method. This method can be used to `poll` and when the future object is *polled*, it returns an enum `Ready` or `Pending` (when the future is not ready).

```rust
enum Poll<T> {
    Ready(T),
    Pending
}
```

When a future returns `Pending` it has to tell the caller, the poller, when it will be possibly ready. For that, it can arrange to call a `wake` function when it might be ready to be polled again.

An example of a future is a timer

```rust
let fut = tokio::time::sleep(Duration::from_millis(50))
```

This is a future that will finished after 50 milliseconds. When we call the `poll` method of the future `fut` and it is polled, it will check whether some time has been passed already. If enough time has passed after the poll, it will return `Ready(())`, otherwise `Pending`.

## Awaiting futures

To poll futures, it is not necessary to use the `poll` method directly. It is actually not recommended.

Instead, there is some syntactic sugar called `async`/`await` that allows a more subtle way to poll futures. Async-await is a specific way to write asynchronous functions, functions that have as output a future. During the execution futures may appear as temporary local variables. These can be **awaited**.

```rust
async fn example() {
    tokio::time::sleep(Duration::from_millis(50)).await
}
```

When a future is awaited by calling `.await`, the `poll` method of the associated future is called. If the poll method returns `Pending`, the current scope (or function call stack) is saved to be returned to later.
If the poll returns `Ready`, the function is just continued.

## Coroutines

If the poll method returns pending, the function is not ready and the stack frame of the function is essentially paused. This means the function is freezed until further notice. The function that can be paused is a **coroutine**. When coroutines pause, we say that the coroutine **yields**. An asynchronous function that is blocked temporarily, yields a stack frame. Later on, the coroutine can be continued by restoring this stack frame.

The asynchronous run-time managing the execution of asynchronous functions will arrange to come back to a paused function. It will resume the function as soon as possible. The run-time may use hints such as the `wake` function of an asynchronous context being called.

## Advanced asynchronous operators

The previous gives rise to a new way of operating on futures, computations that may happen in the future. Futures can be **joined**, which means that all the selected futures are run simultaneously, as much as possible.
