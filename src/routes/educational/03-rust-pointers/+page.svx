# Pointers

Previous lecture: [memory](/educational/02-rust-memory)

## What are pointers

In high-level programming languages, the difference between data and pointers to data is vague. Given a variable, you can assign the old variable to new variables as much as you want and it will magically work.

However, in low-level programming languages, an explicit difference is made between different types of variables:

- **variables**: a location in memory on heap or stack containing data.  This type of variable is *owning* which means that when the variable is dropped, the data it points to is also dropped.
- **pointers**: address to a variable. This type of variable is *non-owning*, which means that the data is not necessarily dropped when this address is dropped.

Pointers are a form of **references**, they "reference" data by pointing to it.

## How to use pointers in Rust

You can create a pointer by prefixing a variable with `&`:

```rust
let a = 1;
let b = &a;
```

When created, you can print the address of a pointer with:

```rust
println!("{:p}", &1);
```

After a pointer is created, you can follow it by writing

```rust
let a = 1;
let b = &a;
assert_eq!(a, *b);
```

This process is called **dereferencing**.

A pointer pointer can be dropped.

## Why pointers?

Benefits:

- You can share (a pointer to) data without copying → faster
- ownership (see previous lecture) is not transferred when creating a pointer →
  - This allows for sharing of data in a larger programs between different components.

## Pointers in other programming languages

C has pointers.

Pointers are missing on the surface of many other mainstream programming languages.

In JS for example, objects behave more like pointers than variables. You can write

```js
let a = {x: 0}
let b = {x: 1}
Object.assign(a, b)
```

This will create two variable pointing to two different objects.

The last assignment turns `a` in a pointer to `b`. This means that names of objects in JavaScript can function like pointers.

## Types of pointers in Rust

A pointer in Rust is any variable that implements the `Deref` trait (which is a kind of type class or interface). This means that is needs to have a *dereferencing* operation implemented.

Rust has two types of pointers:

**immutable** (or read-only) pointers to data which implement `Deref`:

```rust
let age = &29
```

**mutable** pointers to data which implement `DerefMut`:

```rust
let age = &mut 29
```

These references can be used to update the data at the destination address of the pointer.

It is for example possible to modify the data that is referenced by the pointer's address:

```rust
*age = 30;
```

## Role of pointers in Rust

As mentioned before, pointers do not capture and transfer ownership. This means that in the following program the `name` keyword stands for an address to a variable or a reference. Because it is a reference, the expression of `add_suffix` does not capture this variable and receive ownership.

```rust
// replaced variable by a pointer to String
fn add_suffix(&mut name: &String) -> &String { 
    name.push_str(" Jr.");
    return name
} // scope ends but name is not de-allocated
```

Since `add_suffix` did not receive ownership of `name` because it is a non-owning pointer, it is also not responsible for cleaning it up.

This implies that there is no de-allocation of the variable `name` at the end of the `add_suffix` expression.

## Dangling pointers

There are some problems with using pointers. Imagine you have the following situation:

- **input** is a pointer to a memory location
- **output** is a pointer to a memory location

What if the memory location of input is cleaned but not the memory location in the output?

More precisely, in the previous example the local variable `name` was a pointer to some data representing the name, but `add_suffix` also outputs a pointer to the modified name.

```rust
fn add_suffix(&mut name: &String) -> &String {
    name.push_str(" Jr.");
    let modified_name = name // use different name
    return modified_name // unclear how long this will live
    // compared to input name
} 
```

In case the reference to the input `name` is cleaned up, the output `modified_name` should also be cleaned up after the function `add_suffix` ends. If this does not happen, we have a pointer pointing to the output, which itself points into nowhere. This is also called a **dangling pointer**.

## Solution: Life-times

The solution to the dangling pointer problem, is the introduction of **life-times**.

The following function `add_suffix` receives an extra parameter, a life-time that represents the duration in which the reference `name` is a valid reference pointing to real data.

```rust
// added life-time variable
fn add_suffix<'life>(name: &'life mut String) -> &'life String { 
    name.push_str(" Jr.");
    let modified_name = name 
    return modified_name 
    // life-time 'life is at least as long as input life
} 
```

The output of the function `add_suffix` also receives a life-time, and it is exactly the same life-time as the life-time of the input. This means that the life-time of the output is valid for as long as the life-time of the input is valid.

Interpretation:

> Life of the output pointer `modified_name` is shorter than the life of the input pointer `name`. Or in other words, the `name` pointer should exist as long as the `modified_name` pointer exists.

In a sense *life-times* are compile-time **temporal assertions** about pointer validity.

## Combining mutable and immutable references

The combination of writable and read-only pointers may lead to problems.

For example, in the following function, we create a writable mutable reference `&mut first` to the string located at `first`. Later on, we create a read-only reference to the variable `first` when we print it.

```rust
fn main() {
    let mut first = String::from("Ferris"); // creating string
    let full = add_suffix(&mut first); // creating a mutable reference to string
    println!("{full}, originally {first}"); // using an immutable reference to string
}

fn add_suffix<'life>(name: &'life mut String) -> &'life String {
    name.push_str(" Jr.");
    return name
} 
```

This program does not compile because of "borrowing rules". [playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=aa12abe0c71ffe3d1e5c3ba88404d6d8).

The reason is that we cannot both have a writable or mutable reference as an immutable or read-only reference. This happens in the previous code and because it may lead to bugs at run-time, it is forbidden.

## Concurrency

Why would it lead to problems to share immutable with mutable variables? Imagine a scenario where we

1. Create a location with string data `S`
2. Create a reference `R1` to the location of the string `S`.
3. Create another reference `R2` to the location of the string `S`.

More precisely, we do:

```rust
let mut n = 10
let r1 = &n
let r2 = &n

f(r1)
g(r2)
```

What if `f` modifies the data and `g` needs it?

This is not possible in the current case because both references are read-only references.

But if they are mutable references (writable references) and if `f` *modifies the data at the same time* as `g` (for example in a multi-core situation):

```rust
let mut n = 10
let r1 = &mut n
let r2 = &mut n

f(r1)
g(r2)
```

we may introduce bugs because access to the data `n` is not deterministically synchronized. In some cases `f` might be the fastest and in other cases `g` may be the fastest. This is called a **data race**. We want to avoid this.

## Borrowing

To prevent bugs in a multi-core context with mutable pointers, Rust introduces the concept of **borrowing**.

Using a reference to a variable in an expression is called **borrowing the variable**.

The solution to the data race mentioned before exists out of two rules that are enforced by the Rust compiler ar comile time:

1. variables can be **referenced only once as mutable**
2. variables can be **only referenced as immutable anywhere, when referenced immutable once**

The system that enforces this in Rust is called the **borrow-checker** and it will for example prevent the following program from being compiled.

```rust
let mut n = 10
let r1 = &mut n // r1 is a mutable borrow
let r2 = &n // compile time error, only one mutable borrow at the same time

f(r1) // will never be executed, because compile-time error
g(r2)
```

Since it breaks the rule that a variable should referenced immutable everywhere, once it is referenced immutable.

## Summary about memory safety in Rust

By enforcing rules on "borrows", it is less like to encounter "data races" without influencing the life-time of variables.

Next: [types](/educational/04-rust-types)
