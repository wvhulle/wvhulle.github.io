# Basics of Rust

## System vs. Scientific Programming Languages

Programming languages can be broadly divided into three main categories: system programming languages, scientific programming languages, and frontend programming languages. Examples of system programming languages are C, Visual Basic Script, and Rust. These languages are used to create game engines, simulations, system control software, compilers, and more. Examples of scientific programming languages are R, Python, Perl, and SQL. They are typically used for writing maintenance scripts and carrying out short repetitive computational tasks. Examples of frontend programming languages are JavaScript and TypeScript. They are employed in the creation of mobile apps and websites.

## Benefits of System Programming Languages

System programming languages provide better control over dynamic memory and more predictable run-time behavior. This makes them ideal for use in applications such as compilers and system control software.

Rust is an example of a system programming language that has many advantages. It offers low-level control and memory safety, making it highly suitable for the development of secure and reliable pieces of software.

## Variables and Mutability

In Rust, variables are immutable by default. To declare a mutable variable, you use the `mut` keyword.

```rust
let x = 5; // immutable
let mut y = 10; // mutable
```

Python and R allow for variable reassignment without explicit declarations:

```python
# Python
x = 5
x = 10  # Reassignment is allowed
```

```r
# R
x <- 5
x <- 10  # Reassignment is allowed
```

## Data Types

Rust is a statically typed language, and data types need to be declared at compile time. Python and R are dynamically typed.

```rust
let a: i32 = 100;
let b: f64 = 12.34;
let c: bool = true;
```

In Python and R, types are inferred at runtime, so no explicit type annotations are required.

## Control Structures

Control flow in Rust is similar to Python and R but with some syntax differences.

### If Statements

```rust
if x > y {
    println!("x is greater than y");
} else if x < y {
    println!("x is less than y");
} else {
    println!("x is equal to y");
}
```

### Loops

Looping in Rust can be done with several constructs such as `loop`, `while`, and `for`.

```rust
// Infinite loop
loop {
    println!("This will run forever until we break out of it");
}

// While loop
while condition {
    // Loop body
}

// For loop
for i in 0..10 {
    println!("Current value: {}", i);
}
```

## Function Definitions

Functions in Rust are defined using the `fn` keyword and have explicitly typed parameters and return types.

```rust
fn add(x: i32, y: i32) -> i32 {
    x + y // Return value (note that there is no `return` keyword here)
}
```

In Python, functions are defined using `def` and do not require type annotations.

```python
def add(x, y):
    return x + y
```

In R, functions are assigned to variables using `<-` or `=`.

```r
add <- function(x, y) {
    x + y
}
```

## Error Handling

Error handling in Rust is explicit using `Result<T, E>` which can either be `Ok(T)` for success or `Err(E)` for an error.

```rust
fn divide(numerator: f64, denominator: f64) -> Result<f64, &'static str> {
    if denominator == 0.0 {
        Err("Cannot divide by zero.")
    } else {
        Ok(numerator / denominator)
    }
}
```

Python uses try-except blocks, while R has try-catch like mechanisms for dealing with errors.

## Structs and Enums

Rust uses `structs` to create custom data types and `enums` for enumerations.

```rust
struct Point {
    x: i32,
    y: i32,
}

enum Direction {
    Up,
    Down,
    Left,
    Right,
}
```

Python class definition serves multiple purposes (data storage and behavior), while R doesn't have a direct equivalent but uses lists or S3/S4 classes instead.

Transitioning from Python or R to Rust requires adjusting to a more rigid type system and memory management model, but Rust's safety guarantees and speed offer significant benefits once familiarized.

## Pattern Matching

In Rust, pattern matching is a powerful feature provided by the `match` statement. Pattern matching can be used to destructure enums, structs, tuples, and more.

```rust
enum Direction {
    Up,
    Down,
    Left,
    Right,
}

let dir = Direction::Up;

match dir {
    Direction::Up => println!("Going up!"),
    Direction::Down => println!("Going down!"),
    Direction::Left => println!("Going left!"),
    Direction::Right => println!("Going right!"),
}
```

You can also match on values and bind variables in patterns:

```rust
let value = Some(4);

match value {
    Some(x) if x < 5 => println!("Less than five"),
    Some(x) => println!("x is {}", x),
    None => println!("No value"),
}
```

Pattern matching in Python is less expressive but can be done using if-elif-else sequences with comparisons. Python 3.10 introduced structural pattern matching with `match` statements, which look somewhat similar to those in Rust.

```python
# Python 3.10+
direction = 'up'

match direction:
    case 'up':
        print("Going up!")
    case 'down':
        print("Going down!")
    case 'left':
        print("Going left!")
    case 'right':
        print("Going right!")
```

R doesn't have native pattern matching like Rust or Python 3.10. However, one can use nested if-else constructs to simulate simple pattern matching.

```r
dir <- "up"

if (dir == "up") {
    print("Going up!")
} else if (dir == "down") {
    print("Going down!")
} else if (dir == "left") {
    print("Going left!")
} else if (dir == "right") {
    print("Going right!")
}
```

Rust's pattern matching is an integral part of error handling as well, often combined with `Result<T, E>` types to manage errors gracefully. It provides a concise and robust way to handle various cases and conditions in your code.

## Garbage Collection

When writing code, it is important to manage memory properly and ensure that variables are not living longer than necessary. This process is called garbage collection. Memory is a finite resource; if it isnâ€™t managed correctly, we risk having a memory leak, which causes the storage capacity of the system to be exceeded.

Garbage collection is the act of managing dynamic memory allocation throughout the lifetime of a program. Traditionally, this is accomplished by **counting references**: at each important step, the number of references to a variable are tallied. When no references remain, the data can be destroyed.

However, this does create an overhead, as graph algorithms aren't particularly efficient. Fortunately, languages like Rust don't use reference counting. Instead, they rely on strong static rules and compile-time checks to achieve the same effect. Each variable has an "owning expression" or scope responsible for clean-up. For example, when you declare a variable using `let` in a certain code block, the compiler knows that memory allocated to that variables should be released once the code block exits.

## High-performance data-frames in Rust

One more question that may arise: Why not stick to Tidyverse and Pandas for data wrangling?

1. Rust offers a high degree of memory safety and reliability, which is essential for carrying out complex scientific computations without errors.
2. Rust provides low-level control over memory management, making it possible to squeeze more performance out of machines while reducing the risk of buffer overflows and similar security vulnerabilities.
3. In addition, Rust features compile-time checks that alert developers to any potential issues before they can cause any harm, helping to ensure accurate results.  
4. Rust also has strong community support, with many helpful resources online that can assist in getting started quickly. There is a high-performance data-frame library [Polars](https://pola-rs.github.io). It performs similar to or even faster than R in [benchmarks](https://duckdblabs.github.io/db-benchmark/)
5. Finally, Rust has blazingly fast compile speeds and excellent parallelism capabilities, allowing it to process large datasets quickly and efficiently.

Next lecture: [memory](/educational/02-rust-memory)
