# Basics of Rust

## Systems vs. scientific

Programming languages can be largely divided into groups:

- Scientific languages:
  - writing maintenance scripts,
  - short repetitive computational tasks
- Systems languages:
  - game engines,
  - simulations,
  - system control software,
  - compilers
- Frontend languages:
  - writing phone apps
  - writing websites

Examples of these groups are:

- Scientific: R, Python, Perl, SQL
- Systems: C, Visual Basic Script
- Frontend: JavaScript, TypeScript

## Systems programming languages

Benefits:

- Better control over dynamic memory
- More predictable run-time behavior

Rust is a systems language

## Quick introduction of Rust syntax

### Variables

Assigning new variables is done like:

```rust
let x = 10
```

All variables are immutable (constant) by default

Mutable variables are not constant.

```rust
let mut x = 10
```

### Functions

Every function has a type. A function type describes the type of the input and output of the function.

Types for function always have to be provided.

```rust
fn add(a: u8, b: u8) -> u8 {
    a + b
}
```

Note that it is not necessary to write a `return` statement. It is sufficient to have a last line ending without a semicolon.

The type of intermediate variables is inferred where possible based on the function types.

### Structs

Data that shares a context, can be collected inside a `struct`. For example:

```rust
struct Person {
    name: String,
    age: u8
}
```

In other languages they are called:

1. classes in Python
2. S3 classes in R
3. objects or classes in JavaScript
4. also structs in C++

### Pattern matching

In most languages there is a kind of `switch` statement. In Rust, this purpose is fullfilled with the `match` statement which is more powerful.

```rust
let person = Person { name: "Willem".to_string() }
let pattern = Some(person)

match pattern  {
  Some(Person { name }) => println!("Hello {}", name),
  None => println!("Hello no-one")
}
```

## Garbage collection

Programming languages use memory and the life-time of memory is determined by the language and users of the language. Some variables may be short-lived, others not. When all the data is kept forever, the storage capacity is exceeded and we have a memory leak. We need to manage memory properly.

Garbage collection is the act of managing dynamic memory allocation throughout the life-time of a program. Usually this is done by counting references. **Reference counting** works as follows:

1. At each important step, count the number of references to a variable
2. When no references remaining, destroy the data

The references form a directed graph which may be cyclic. Reference counting amounts to looking for disjoint parts in the graph. Graph algorithms are not efficient, so reference counting creates an overhead.

## Solution to lack of garbage collection

Garbage collection in Rust is usually:

- not done by counting references.
- done with strong static compile-time (and run-time) rules

How is this done? Every variable has an **owning expression** or scope responsible for clean-up. See the next lecture.

## High-performance data-frames in Rust

One more question that may arise: Why not stick to Tidyverse and Pandas for data wrangling?

There is a high-performance library available: [Polars](https://pola-rs.github.io)
It performs similar to or even faster than R in [benchmarks](https://duckdblabs.github.io/db-benchmark/)

Next lecture: [memory](/educational/02-rust-memory)
