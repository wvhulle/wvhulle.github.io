
## Basics of Rust

### Systems vs. scientific

Comparison:

- Scientific languages:
  - writing maintenance scripts,
  - short repetitive computational tasks
- Systems languages:
  - game engines,
  - simulations,
  - system control software,
  - compilers
- Frontend languages:
  - writing phone apps
  - writing websites

Examples:

- Scientific: R, Python, Perl, SQL
- Systems: C, Visual Basic Script
- Frontend: JavaScript, TypeScript

### Systems programming languages

Benefits:

- Better control over dynamic memory
- More predictable run-time behavior

Rust is a systems language


### Variables

Assigning new variables is done like:

```rust
let x = 10
```

All variables are immutable (constant) by default

Mutable variables are not constant.

```rust
let mut x = 10
```

### Functions

Every function has a type. A function type describes the type of the input and output of the function.

Types for function always have to be provided.

```rust
fn add(a: u8, b: u8) -> u8 {
    a + b
}
```

Not that it is not necessary to write a `return` statement. It is sufficient to have a last line ending without a semicolon.

The type of intermediate variables is inferred where possible based on the function types.

### Structs

Data that shares a context, can be collected inside a `struct`. For example:

```rust
struct Person {
    name: String,
    age: u8
}
```

In other languages they are called:

1. classes in Python
2. S3 classes in R
3. objects or classes in JavaScript
4. also structs in C++

### Pattern matching


In most languages there is a kind of `switch` statement. In Rust, this purpose is fullfilled with the `match` statement which is more powerful.

```rust
let person = Person { name: "Willem".to_string() }
let pattern = Some(person)

match pattern  {
  Some(Person { name }) => println!("Hello {}", name),
  None => println!("Hello no-one")
}
```

### Garbage collection

Garbage collection is about managing memory allocation. Usually this is done by counting references.

1. Count number of references to data
2. No references remaining 
3. destroy data exactly once

This creates an overhead.

### Solution to lack of garbage collection

Garbage collection in Rust is:

- not done by counting references.
- done with strong static compile-time (and run-time) rules

Every variable has an **owning expression** or scope responsible for clean-up

Next lecture: [memory](/educational/02-rust-memory)