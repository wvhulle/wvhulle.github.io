# Functional programming

Previous lecture: [object-oriented programming](/educational/06-python-object-oriented)

Existing literature:

- A famous book with a philosophical background on functional programming is [Structure and Interpretation of Computer Programs](https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs)

**Functional Programming (FP)** and **Object-Oriented Programming (OOP)** are two predominant programming paradigms, each with its own principles and approaches to solving problems. FP offers several distinctive advantages over OOP in various scenarios. Functional programming as a concept is older than object-oriented programming and dates back to abstract models for computing in 1940 such as lambda calculus. It was implemented for the first time in 1960 in Lisp. In functional programming all computations are treated as the result of applying mathematically sound functions without side effects.

## 1. Immutability

A returning concept in functional programming are data structures that never change their state after creation, enabling safer concurrency and predictable code behavior. Rust, despite not being a purely functional language, encourages the use of immutable data structures to ensure safety and concurrency without data races. All variables in Rust are immutable by default and have to be declared as mutable explicitly.

For example, the following will not compile

```rust
let x = 5;
x = 6; // This will cause a compile-time error because `x` is immutable.
```

In general, it is necessary, while modeling a system, to distinguish constant and mutable data from the very beginning. 

This leads to:

- Predictability: Immutable variables lead to more predictable code. When you see a variable being used multiple times in a function or across functions, you can be confident that its value hasn't been altered since initialization, which makes it easier to follow and reason about the program's flow.
- Concurrency safe: Rust aims to prevent data races at compile time. If multiple threads have access to immutable data, there's no risk of one thread unexpectedly modifying the data while another is reading it. This reduces the need for locks and simplifies writing concurrent programs.
- Compiler optimizations: Knowing that a variable won't change allows the compiler to optimize code under the hood. It could cache the value or elide certain checks, leading to potentially better performance.


## 2. First-Class and Higher-Order Functions

Functions are the building blocks of functional programming. Remember that a function is a map from a source A to a target B. Functions in functional programming are very similar to functions in mathematics.

FP treats functions as first-class citizens, allowing them to be assigned to variables, passed as arguments, or returned by other functions. Higher-order functions can take other functions as parameters or return them, leading to powerful abstractions.

### Example 

Inspired by biology, let's create a series of functions that mimic the actions of different enzymes in a metabolic pathway, where each enzyme (function) might modify a substrate and pass it on to the next enzyme.

```rust
fn main() {
    // Define a sequence of 'substrates', in this case a string representing a molecule
    let initial_substrate = "molecule";

    // Functions representing different enzymes in a metabolic pathway
    let enzyme1 = |substrate: &str| format!("{}-modified-by-enzyme1", substrate);
    let enzyme2 = |substrate: &str| format!("{}-modified-by-enzyme2", substrate);
    let enzyme3 = |substrate: &str| format!("{}-modified-by-enzyme3", substrate);

    // Pass functions as arguments to simulate the metabolic pathway
    let result = metabolic_pathway(initial_substrate, enzyme1, enzyme2, enzyme3);

    println!("Final product: {}", result); // Output the final product of the metabolic pathway
}

// Function simulating a metabolic pathway where enzymes are applied in sequence
fn metabolic_pathway(
    start: &str,
    enzymatic_process1: fn(&str) -> String,
    enzymatic_process2: fn(&str) -> String,
    enzymatic_process3: fn(&str) -> String,
) -> String {
    let intermediate1 = enzymatic_process1(start);
    let intermediate2 = enzymatic_process2(&intermediate1);
    enzymatic_process3(&intermediate2)
}
```

In this code:

- We define three closures (`enzyme1`, `enzyme2`, `enzyme3`) that represent the action of different enzymes.
- We pass these closures as arguments to a function called `metabolic_pathway`, showing how functions can be treated as first-class citizens in Rust. Each function modifies the input in some way, mimicking the transformation of a substrate by an enzyme.
- The final output shows the product after it has been processed by all three enzymatic functions, simulating a series of reactions in a biological metabolic pathway.


### Naming

Because functions are considered building blocks, they have to be properly named and have a clear declaration. A proper function name and declaration are a form of documentation. Using good names is like writing a love letter to the next person who will read your code. On top, functions should be simple to understand and take as few arguments as possible, certainly never more than a handful.

## 3. Pure Functions

FP emphasizes pure functions, without side effects, which means that given the same input, a function will always produce the same output. This predictability facilitates testing and concurrent code execution.

**Biology example**: A pure function is akin to a physiological function like photosynthesis that always converts CO₂ and water into glucose and oxygen given light energy, regardless of external conditions, similar to a function always producing the same output for the same set of inputs.

Consequences:

1. Predictability: Since expressions can be substituted with their results, you know exactly what they will do based on their inputs. Also called referential transparency, meaning that a function call can be replaced with its resulting value without changing the program's behavior
2. Parallelization: functions can easily run in parallel because they don't rely on shared mutable state.
3. Cache-ability: The result of an expression can be cached and reused because it will always produce the same output for the same inputs.
4. Ease of Refactoring: You can freely refactor your code by replacing expressions with variables or other expressions without worrying about altering the behavior of your program.

## 4. Recursion Over Loops

FP favors recursion for repetitive tasks instead of iterative loops common in OOP. This aligns well with mathematical functions and can simplify certain algorithms at the expense of potential performance drawbacks like stack overflow.

### Example

The structure of a fractal, like the Romanesco broccoli, naturally exhibits recursive patterns, similar to how FP uses recursive structures and functions.

![brocolli](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Romanesco_broccoli_%28Brassica_oleracea%29.jpg/750px-Romanesco_broccoli_%28Brassica_oleracea%29.jpg)

In Rust, recursion can sometimes be a more natural fit for algorithms that model biological processes or systems when those processes are inherently recursive. An example of such a process is calculating the (n)th number in the Fibonacci sequence, which appears in various natural phenomena including branching in trees, the arrangement of leaves on a stem, the fruitlets of a pineapple, the flowering of an artichoke, and the unfurling of a fern.

Here's an idiomatic Rust example of a recursive function to calculate the (n)th Fibonacci number:

```rust
fn main() {
    let n = 10;
    println!("The {}th Fibonacci number is {}", n, fibonacci(n));
}

// A recursive function to calculate the nth Fibonacci number
fn fibonacci(n: u32) -> u32 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci(n - 1) + fibonacci(n - 2),
    }
}
```

> The 10th Fibonacci number is 55

Using recursion to solve such a problem can be clear and concise, especially when translating a naturally recursive mathematical definition into code. However, this naive recursive approach is inefficient for large (n) because it performs many redundant calculations. It has exponential time complexity due to the repeated work done at each level of recursion. 

It would be more efficient to use an iterative approach. However, it can also be sufficient to use a tail-call. A tail call is a recursive call at the end of a function. This type of function can be optimized by the compiler into a loop. 

### 5. Expressiveness

FP can lead to more concise and expressive code, which can be easier to read and maintain once the paradigm is fully understood.

In JavaScript, which supports functional programming concepts, combining `map`, `reduce`, and `filter` functions showcases the expressiveness of the language. These functions can operate on arrays to transform, filter, and accumulate values in a clear declarative style.

Here's an example that demonstrates their combined use:

```javascript
// A sample array of objects representing people with age and name
const people = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 20 },
  { name: "Carol", age: 30 },
  { name: "Dave", age: 35 },
  { name: "Eve", age: 40 }
];

// We want to calculate the average age of people older than 25
const averageAge = people
  .filter(person => person.age > 25) // Filter out people aged 25 or below
  .map(person => person.age)         // Transform the filtered list into a list of ages
  .reduce((acc, age, _, array) => {  // Reduce to accumulate ages and compute average
    acc += age;
    return array.length - 1 === index ? acc / array.length : acc;
  }, 0);

console.log(averageAge); // Expected output: Average age of people older than 25
```

Let's go step by step:

1. **Filter**: The `filter` function is used first to obtain only the people whose ages are above 25.
2. **Map**: After filtering, we use the `map` function on the resulting array to extract just the ages of the remaining people.
3. **Reduce**: Finally, the `reduce` function accumulates the ages and computes the average by dividing the accumulated sum by the length of the filtered array.

This chain of `filter`, `map`, and `reduce` demonstrates how you can clearly and succinctly express a complex data transformation without having to write imperative loops and temporary variables. It shows what needs to be done, abstracting away the details of how it should be implemented under the hood.





### 6. Stronger Emphasis on Type Systems

Many functional languages encourage strong static type systems, which can reduce bugs by catching errors at compile time.

**Biology example**: The body's immune system distinguishes between different types of cells based on markers, akin to strong typing systems distinguishing between data types.


It is possible to put an entire formal logic into a type system. Functions become implications and so on. In this way, whole fields of mathematics can be embedded in code. To do this, you have to introduce a concept known as *dependent types* which are types that are constructed from values of other types. For example, a type of vectors of fixed length N. See languages such as Agda and Coq. 

#### Example in mathematics

There are many interesting and complex proofs in mathematics that can be represented in Agda. Let's consider a proof about the existence and uniqueness of inverses in group theory. In group theory, a group is a set equipped with an operation satisfying certain axioms: closure, associativity, identity, and invertibility.


```agda
record Group : Set₁ where
  field
    Carrier   : Set
    ε         : Carrier
    _∙_       : Carrier → Carrier → Carrier
    _⁻¹       : Carrier → Carrier
    _≈_       : Carrier → Carrier → Set
    assoc     : ∀ {x y z} → x ∙ (y ∙ z) ≈ (x ∙ y) ∙ z
    identityʳ : ∀ x → x ∙ ε ≈ x
    identityˡ : ∀ x → ε ∙ x ≈ x
    inverseʳ  : ∀ x → x ∙ x ⁻¹ ≈ ε
    inverseˡ  : ∀ x → x ⁻¹ ∙ x ≈ ε
    ∙-congˡ   : ∀ {x y z} → x ≈ y → x ∙ z ≈ y ∙ z
    ∙-congʳ   : ∀ {x y z} → y ≈ z → x ∙ y ≈ x ∙ z
```
We'll prove that if a certain element in a group has an inverse, this inverse is unique. 

This example illustrates a proof carried out in the context of abstract algebra (group theory) and demonstrates the power of type theories and dependent types in capturing mathematical structures.

```agda
  identityˡ-unique : ∀ x y → x ∙ y ≈ y → x ≈ ε
  identityˡ-unique x y eq = begin
    x              ≈˘⟨ identityʳ x ⟩
    x ∙ ε          ≈˘⟨ ∙-congˡ (inverseʳ y) ⟩
    x ∙ (y ∙ y ⁻¹) ≈˘⟨ assoc x y (y ⁻¹) ⟩
    (x ∙ y) ∙ y ⁻¹ ≈⟨ ∙-congʳ eq ⟩
         y  ∙ y ⁻¹ ≈⟨ inverseʳ y ⟩
    ε              ∎
```

See https://alexarice.github.io/posts/strict-group-theory.html

The proof above is a non-trivial example that combines dependently typed programming with mathematical theorem proving. It demonstrates how Agda can encode and verify fundamental properties of abstract algebraic structures.

#### Example: conditional types

In the previous example, we used a kind of dependent typing. Dependent typing exists also in more mainstream languages. One kind of dependent typing is conditional typing in TypeScript. 

Imagine modeling biological entities where we want to define a type that depends on whether the entity is a plant or an animal:

```typescript
type LivingOrganism<T extends "plant" | "animal"> =
  T extends "plant"
    ? { species: string; photosynthesis: boolean }
    : { species: string; heartRate: number };

// Usage
let fern: LivingOrganism<"plant"> = {
  species: "Pteridophyta",
  photosynthesis: true,
};

let tiger: LivingOrganism<"animal"> = {
  species: "Panthera tigris",
  heartRate: 120,
};
```

In this TypeScript example, we have a conditional type `LivingOrganism` whose structure changes based on whether it represents a plant or an animal. To do this, we use the ternary if then operator.

##### Relation to Type Systems and Dependent Type Form

TypeScript's conditional types are reminiscent of dependent typing because a type choice is made based on another type (although not on runtime values).

Agda and Coq have more sophisticated forms of dependent types, where the type can depend on specific values. In these systems, you could express constraints such as "an array of exactly `n` elements," with `n` being a compile-time constant or even a value computed at runtime, something not possible with TypeScript's static type system.

However, through conditional types, TypeScript does allow for a form of compile-time type dependency, which adds a level of safety and expressivity to the language similar in spirit to some uses of dependent types, albeit with much less power than seen in Agda or Coq.


### OOP vs Functional programming

#### Example: Modeling an Ecosystem

Imagine modeling an ecosystem with species interactions such as predation, competition, and symbiosis.

**With OOP**, you might define classes for individual species with methods to express behaviors and properties to store current states like population size. Interactions would involve altering the states of these objects, potentially involving complex chains of mutual state updates when multiple species interact.

**Using FP**, you would model an ecosystem as a series of transformations of a state represented by a collection of data structures. Each interaction is a function that takes a state and returns a new state without modifying the original. Complex interactions are composed of simpler functions that are easy to reuse and test. For example, population changes due to predation would be modeled as a function that takes the current populations and returns the new populations, accounting for the consumption rates, without altering the original state.

Overall, FP adds a perspective that emphasizes safety, purity, and transformations, while OOP focuses on encapsulating state and behavior within objects. Each has its strengths, and modern programming often benefits from combining aspects of both paradigms.

Next lecture: [functional design patterns](/educational/09-rust-functional-design-patterns)
