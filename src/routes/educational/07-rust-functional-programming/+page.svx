# Functional programming

Previous lecture: [object-oriented programming](/educational/06-python-object-oriented)

Existing literature:

- A famous book with a philosophical background on functional programming is [Structure and Interpretation of Computer Programs](https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs)

**Functional Programming (FP)** and **Object-Oriented Programming (OOP)** are two predominant programming paradigms, each with its own principles and approaches to solving problems. FP offers several distinctive advantages over OOP in various scenarios:

## 1. Immutability

A returning concept in functional programming are data structures that never change their state after creation, enabling safer concurrency and predictable code behavior. Rust, despite not being a purely functional language, encourages the use of immutable data structures to ensure safety and concurrency without data races. All variables in Rust are immutable by default and have to be declared as mutable explicitly.

For example, the following will not compile

```rust
let x = 5;
x = 6; // This will cause a compile-time error because `x` is immutable.
```

This leads to:

- Predictability: Immutable variables lead to more predictable code. When you see a variable being used multiple times in a function or across functions, you can be confident that its value hasn't been altered since initialization, which makes it easier to follow and reason about the program's flow.
- Concurrency safe: Rust aims to prevent data races at compile time. If multiple threads have access to immutable data, there's no risk of one thread unexpectedly modifying the data while another is reading it. This reduces the need for locks and simplifies writing concurrent programs.
- Compiler optimizations: Knowing that a variable won't change allows the compiler to optimize code under the hood. It could cache the value or elide certain checks, leading to potentially better performance.


## 2. First-Class and Higher-Order Functions

Functions are the building blocks of functional programming. Remember that a function is a map from a source A to a target B. Functions in functional programming are very similar to functions in mathematics.

FP treats functions as first-class citizens, allowing them to be assigned to variables, passed as arguments, or returned by other functions. Higher-order functions can take other functions as parameters or return them, leading to powerful abstractions.

### Example 

Inspired by biology, let's create a series of functions that mimic the actions of different enzymes in a metabolic pathway, where each enzyme (function) might modify a substrate and pass it on to the next enzyme.

```rust
fn main() {
    // Define a sequence of 'substrates', in this case a string representing a molecule
    let initial_substrate = "molecule";

    // Functions representing different enzymes in a metabolic pathway
    let enzyme1 = |substrate: &str| format!("{}-modified-by-enzyme1", substrate);
    let enzyme2 = |substrate: &str| format!("{}-modified-by-enzyme2", substrate);
    let enzyme3 = |substrate: &str| format!("{}-modified-by-enzyme3", substrate);

    // Pass functions as arguments to simulate the metabolic pathway
    let result = metabolic_pathway(initial_substrate, enzyme1, enzyme2, enzyme3);

    println!("Final product: {}", result); // Output the final product of the metabolic pathway
}

// Function simulating a metabolic pathway where enzymes are applied in sequence
fn metabolic_pathway(
    start: &str,
    enzymatic_process1: fn(&str) -> String,
    enzymatic_process2: fn(&str) -> String,
    enzymatic_process3: fn(&str) -> String,
) -> String {
    let intermediate1 = enzymatic_process1(start);
    let intermediate2 = enzymatic_process2(&intermediate1);
    enzymatic_process3(&intermediate2)
}
```

In this code:

- We define three closures (`enzyme1`, `enzyme2`, `enzyme3`) that represent the action of different enzymes.
- We pass these closures as arguments to a function called `metabolic_pathway`, showing how functions can be treated as first-class citizens in Rust. Each function modifies the input in some way, mimicking the transformation of a substrate by an enzyme.
- The final output shows the product after it has been processed by all three enzymatic functions, simulating a series of reactions in a biological metabolic pathway.


### Naming

Because functions are considered building blocks, they have to be properly named and have a clear declaration. A proper function name and declaration are a form of documentation. Using good names is like writing a love letter to the next person who will read your code. On top, functions should be simple to understand and take as few arguments as possible, certainly never more than a handful.

## 3. Pure Functions

FP emphasizes pure functions, without side effects, which means that given the same input, a function will always produce the same output. This predictability facilitates testing and concurrent code execution.

**Biology example**: A pure function is akin to a physiological function like photosynthesis that always converts CO₂ and water into glucose and oxygen given light energy, regardless of external conditions, similar to a function always producing the same output for the same set of inputs.

Consequences:

1. Predictability: Since expressions can be substituted with their results, you know exactly what they will do based on their inputs. Also called referential transparency, meaning that a function call can be replaced with its resulting value without changing the program's behavior
2. Parallelization: functions can easily run in parallel because they don't rely on shared mutable state.
3. Cache-ability: The result of an expression can be cached and reused because it will always produce the same output for the same inputs.
4. Ease of Refactoring: You can freely refactor your code by replacing expressions with variables or other expressions without worrying about altering the behavior of your program.

## 4. Recursion Over Loops

FP favors recursion for repetitive tasks instead of iterative loops common in OOP. This aligns well with mathematical functions and can simplify certain algorithms at the expense of potential performance drawbacks like stack overflow.

### Example

The structure of a fractal, like the Romanesco broccoli, naturally exhibits recursive patterns, similar to how FP uses recursive structures and functions.

![brocolli](https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Romanesco_broccoli_%28Brassica_oleracea%29.jpg/750px-Romanesco_broccoli_%28Brassica_oleracea%29.jpg)

In Rust, recursion can sometimes be a more natural fit for algorithms that model biological processes or systems when those processes are inherently recursive. An example of such a process is calculating the (n)th number in the Fibonacci sequence, which appears in various natural phenomena including branching in trees, the arrangement of leaves on a stem, the fruitlets of a pineapple, the flowering of an artichoke, and the unfurling of a fern.

Here's an idiomatic Rust example of a recursive function to calculate the (n)th Fibonacci number:

```rust
fn main() {
    let n = 10;
    println!("The {}th Fibonacci number is {}", n, fibonacci(n));
}

// A recursive function to calculate the nth Fibonacci number
fn fibonacci(n: u32) -> u32 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci(n - 1) + fibonacci(n - 2),
    }
}
```

> The 10th Fibonacci number is 55

Using recursion to solve such a problem can be clear and concise, especially when translating a naturally recursive mathematical definition into code. However, this naive recursive approach is inefficient for large (n) because it performs many redundant calculations. It has exponential time complexity due to the repeated work done at each level of recursion.

For efficient computation, one would typically use an iterative approach or memoization (dynamic programming) to avoid recalculating the same values. In biological systems, similar optimization strategies might occur, but they wouldn't necessarily be implemented through code—it would be through the evolution of more efficient physical structures and processes.

Nonetheless, if you specifically want a recursive solution to a biological problem that is preferred over loops, it's worth noting that real-world preference generally arises from how elegantly recursion can represent the solution rather than from a computational efficiency standpoint.

### 5. Expressiveness

FP can lead to more concise and expressive code, which can be easier to read and maintain once the paradigm is fully understood.

**Biology example**: DNA transcription and translation are very efficient and compact ways to synthesize proteins. Similarly, FP strives for expressiveness through concise and efficient code.

### 6. Stronger Emphasis on Type Systems

Many functional languages encourage strong static type systems, which can reduce bugs by catching errors at compile time.

**Biology example**: The body's immune system distinguishes between different types of cells based on markers, akin to strong typing systems distinguishing between data types.

It is possible to put an entire formal logic into a type system. Functions become implications and so on. In this way, whole fields of mathematics can be embedded in code. See languages such as Agda and Coq. 

#### Example

There are many interesting and more complex proofs in mathematics that can be represented in Agda. Let's consider a proof about the existence and uniqueness of inverses in group theory. In group theory, a group is a set equipped with an operation satisfying certain axioms: closure, associativity, identity, and invertibility.



```agda
{-# OPTIONS --without-K --exact-split --safe #-}

open import Relation.Binary.PropositionalEquality as Eq using (_≡_; refl; cong)
open Eq.≡-Reasoning

record Group : Set₁ where
  field
    Carrier   : Set
    ε         : Carrier
    _∙_       : Carrier → Carrier → Carrier
    _⁻¹       : Carrier → Carrier
    _≈_       : Carrier → Carrier → Set
    assoc     : ∀ {x y z} → x ∙ (y ∙ z) ≈ (x ∙ y) ∙ z
    identityʳ : ∀ x → x ∙ ε ≈ x
    identityˡ : ∀ x → ε ∙ x ≈ x
    inverseʳ  : ∀ x → x ∙ x ⁻¹ ≈ ε
    inverseˡ  : ∀ x → x ⁻¹ ∙ x ≈ ε
    ∙-congˡ   : ∀ {x y z} → x ≈ y → x ∙ z ≈ y ∙ z
    ∙-congʳ   : ∀ {x y z} → y ≈ z → x ∙ y ≈ x ∙ z


```
We'll prove that if a certain element in a group has an inverse, this inverse is unique. 

This example illustrates a proof carried out in the context of abstract algebra (group theory) and demonstrates the power of type theories and dependent types in capturing mathematical structures.

```agda
  identityˡ-unique : ∀ x y → x ∙ y ≈ y → x ≈ ε
  identityˡ-unique x y eq = begin
    x              ≈˘⟨ identityʳ x ⟩
    x ∙ ε          ≈˘⟨ ∙-congˡ (inverseʳ y) ⟩
    x ∙ (y ∙ y ⁻¹) ≈˘⟨ assoc x y (y ⁻¹) ⟩
    (x ∙ y) ∙ y ⁻¹ ≈⟨ ∙-congʳ eq ⟩
         y  ∙ y ⁻¹ ≈⟨ inverseʳ y ⟩
    ε              ∎
```

See https://alexarice.github.io/posts/strict-group-theory.html

The proof above is a non-trivial example that combines dependently typed programming with mathematical theorem proving. It demonstrates how Agda can encode and verify fundamental properties of abstract algebraic structures.

### OOP vs Functional programming

#### Example: Modeling an Ecosystem

Imagine modeling an ecosystem with species interactions such as predation, competition, and symbiosis.

**With OOP**, you might define classes for individual species with methods to express behaviors and properties to store current states like population size. Interactions would involve altering the states of these objects, potentially involving complex chains of mutual state updates when multiple species interact.

**Using FP**, you would model an ecosystem as a series of transformations of a state represented by a collection of data structures. Each interaction is a function that takes a state and returns a new state without modifying the original. Complex interactions are composed of simpler functions that are easy to reuse and test. For example, population changes due to predation would be modeled as a function that takes the current populations and returns the new populations, accounting for the consumption rates, without altering the original state.

Overall, FP adds a perspective that emphasizes safety, purity, and transformations, while OOP focuses on encapsulating state and behavior within objects. Each has its strengths, and modern programming often benefits from combining aspects of both paradigms.

Next lecture: [functional design patterns](/educational/09-rust-functional-design-patterns)
