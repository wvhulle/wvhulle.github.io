# Posts

Work-in-progress.

## The type system of Rust 
_Ghent, 2024-10-24_

## Types

There are also some more exotic types in Rust:

- General algebraic datatypes (GADTs)?
  - product types: tuples, structs
  - sum types: enums
  - combinations: 
    - enums with variants being structs
    - structs with fields being enums

## Categorizations of types

There are two kinds of types:

- types with values that have an upper bound on the size: 
  - go on the stack
  - fixed size on stack
  - operations can be easier optimized
- types with values that can grow: 
  - go on the heap
  - cost more time

Avoid all heap allocations as much as possible.

## Basic operators

Question:

```rust
fn main() {
    let mut x = 4;
    --x;
    print!("{}{}", --x, --x);
}
```

no unary increment or decrement operator in Rust

Why? To simplify parsing and reasoning.

## Scope allocation

Semantics
- Local variable assignments allocate data on the stack
- The data remains allocated until the end of the scope
- At the end of the scope of the variable, data is deallocated

Syntax
- A scope is delimited by curly braces

Examples
- code that locks a mutex essentially includes the logic that the lock will be released when execution leaves the scope of the object

Synonyms
- With blocks in Python and file handles
- in C++: Resource Acquisition Is Initialization (RAII)

## Destructors

Called when allocation is deallocated.

### Infallible matching and destructors

#### Question
What is the output of this Rust program?

```rust
use std::fmt::{self, Display};

struct S;

impl Display for S {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        formatter.write_str("1")
    }
}

impl Drop for S {
    fn drop(&mut self) {
        print!("2");
    }
}

fn f() -> S {
    S
}

fn main() {
    let S = f();
    print!("{}", S);
}
```

#### Short answer

This program prints 212.


#### Long answer

No value of type S gets dropped within the body of function f. The function f conjures an S and returns ownership of it to the caller of f; the caller determines when to drop the S of which it received ownership.

On the first line of main, we call f() and perform an infallible match that binds no new variables. As no variables are declared on this line, there is no variable that could be the owner of the S returned by f() so that S is dropped at that point, printing 2. The S in let S = f() is a unit struct pattern (not a variable name) that matches a value of type S via destructuring but does not bind the value to any variable.

The second line of main conjures a new S, prints it, and drops it at the semicolon.

## Ownership

Synonyms:
- Object lifetime
- Region based memory allocation

Semantics
- a way to manage finite resources such as the stack and the heap
- an extension of scope based resource management

## Encoding ownership in types

inside blocks and expressions, there are two categories of variables, members and fields:
- owning types: 
  - types that are owned by the current block
  - Owning variables are bound to a scope
  - may pass ownership to a different scope
  - as long as they have the ownership, they are responsible for destroying or de-initializing the data they refer to a the end of the scope
  - cannot be duplicated to avoid resource usage
- non-owning types: types that are not owned by the current block
  - can be more easily duplicated because they do not use as much resources.

## Type theory

Way to verify safety of computer programs.

Similar to logic.

Natural deduction describes inference.

## Substructural logic

a structural rule is an inference rule of a sequent calculus that does not refer to any logical connective but instead operates on the sequents directly

What are the structural rules 

- Exchange: two members on the same side may be swapped
- Weaking: a hypothesis or conclusion may be extended with additional members
- Contraction: two equal members on the same side may be replaced by a single member

## Affine type theory  

No structural rule called contraction

See [Boats](https://without.boats/blog/ownership/)

```
————————————   ————————————
 x:T |- x:T     x:T |- x:T
———————————————————————————
 x:T, x:T |- (x,x) : (T,T)
——————————————————————————— <- contraction!!
   x:T |- (x,x) : (T,T)
  ———————————————————————
   λx.(x,x) : T -> (T,T)
```
Taken from [Reddit](https://www.reddit.com/r/rust/comments/eaf5ko/what_logic_does_rusts_rules_correspond_to/)

Consequence of the lack of the rule of contraction: 
- values cannot be duplicated by default
- types that are owned cannot be consumed twice

To make owned types duplicatable you have to make them `Copy` in Rust.

## Concurrent separation logic

Modelling computations utilizing resources.

Using Hoare logic.

Intermediate
https://www.youtube.com/watch?v=1GjSfyijaxo

Advanced:

- The general framework: https://iris-project.org/tutorial-pdfs/iris-lecture-notes.pdf
- Applied to Rust: https://iris-project.org/pdfs/2024-pldi-refinedrust.pdf

## Ownership as a tree


- ownership is also applied to nested data structures
- The owner can be moved without moving his children

Syntax:
- Invisible when created
- Visible in the error messages 
  - when trying to use a variable that has been moved

Consequences:
- Every piece of data in Rust has an owner
- The root owner is a code block
- Ownership relationship forms disjoint trees


## Root ownership 

Semantics
- The roots of the ownership tree are locally declared variables inside blocks. 
- Declared local variables are owned by the surrounding block. 
- Local variables are the top-most "owned" type

Implementation
- on the stack

Syntax:
- With `let`: locally declared variables

Examples:
- arrays
- numbers
- characters

### Constructors and drop

#### Question

```rust
struct S;

impl Drop for S {
    fn drop(&mut self) {
        print!("1");
    }
}

fn main() {
    let s = S;
    let _ = s;
    print!("2");
}
```

## Ownership indirection

Semantics
- local variables can own data on the heap
- data on the heap can own other data on the heap
- gives a level of indirection, 
- ownership relationships between children of the ownership tree

Examples
- A vector points to and owns a buffer on the heap, it indirectly owns the value at each index.
- A struct owns the values of each field
- An enum variant owns the values of each field
- **smart pointers**: container types that own data that is allocated on the heap.
  - A `Box` 
  - A more complicated version is  `RefCell`, which enables some kind of locking so that no more than variable can modify the content at the same time. 
  - The multi-threaded version of `RefCell` is `Mutex`. A mutex is a programming concept that is frequently used to solve multi-threading problems. It is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.
  
Related:
- C also has owning smart pointers such as mutexes.

## Sharing ownership

By default all variables have a single owner. If you want, you can create data that has multiple owners through `Rc` and `Arc`
Instances of this type can be cloned, when no instances remain, the reference count becomes zero and the data is de-allocated. This is called *reference counting*. Reference counting is the default way to share data in standard garbage-collected dynamic languages.

### Size of shared references

https://dtolnay.github.io/rust-quiz/30

#### Question

```rust
use std::rc::Rc;

struct A;

fn p<X>(x: X) {
    match std::mem::size_of::<X>() {
        0 => print!("0"),
        _ => print!("1"),
    }
}

fn main() {
    let a = &A;
    p(a);
    p(a.clone());
    
    let b = &();
    p(b);
    p(b.clone());
    
    let c = Rc::new(());
    p(Rc::clone(&c));
    p(c.clone());
}
```

#### Short answer

111011

## Moving ownership

Semantics:
- Transfer the ownership of allocated data to another place in the program
- The original location of the ownership parent is deallocated

Syntax:
- Invisible

Implementation
- Moving data that is owner of some other data will not move all its children in memory
- Only a shallow copy is made

Examples:
- Moving through assignment
- Moving through assignment of blocks: transfers ownership of the variable associated with the last expression to the outer block
- Moving through capturing
  - Capture by constructors
  - Capture by functions

Related:
- In C++ a deep copy is made when assigning owning expressions



#### Short answer

The output is 21.
 
#### Long answer
In fact s does not get moved and

## References


Synonyms
- a *borrow*. Using references in Rust is called *borrowing* data. 

Semantics
- An alias of a piece of data that does not capture ownership, not responsible for cleaning up
- Can be dropped manually or at the end of the scope. 

Implementation:
- an address on the stack (local reference variables) or the heap (smart pointers)
- may contain extra data such as length or size 
- The address of a reference can be printed with `println!("{:p}", &1);`.

Advantages:
- You can share data without copying, so they can increase the speed of your program.

## Referents

The referent is the data at the location pointed to by a reference. We say that the referent is **being borrowed** by its references.

Referents cannot be moved out. 


## Dereferencing 

Semantics
A reference in Rust is any variable that implements the `Deref` trait (which is a kind of type class or interface). This means that it needs to have a *dereferencing* operation implemented.

Syntax
The dereference operator `*` can appear on two sides of an assignment:

- On the left of an assignment 
  - can be used to update the value pointed to by a mutable reference if that value is declared mutable
- On the right of an assignent: accesses the value behind a reference
  - for references that point to copy types it will create a copy and assignment to the left 
    - types such as integers
  - for references that point to non-copy types, it will create a compile time error, since the ownership can not be moved through a reference

## Lifetimes

Syntax:
- `'a`

Semantics:
- The lifetime of a reference. The logical timeframe within your program that a reference is valid. 
- Cannot shrink or grow

Usage:
- Lifetimes can be elided or omitted? See https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md
- When elided, the compiler will choose the shortest lifetime based on all the code paths.
- Should be given meaningful names

Quiz questions:
- What is the meaning of `&'static T`?

Related:
- Which other programming languages support lifetimes?


## Immutable references 

Syntax: `&`

Semantics:
- make an alias for existing immutable data
- allows creation of multiple immutable references to the same data
- all data owned by the aliased referent becomes read-only

Advantages
- allows for sharing of data in a larger programs between different components. 



https://dtolnay.github.io/rust-quiz/6
```rust
use std::mem;

fn main() {
    let a;
    let a = a = true;
    print!("{}", mem::size_of_val(&a));
}
```

```rust
let a;
let b = a = true;
print!("{}", mem::size_of_val(&b));
```

```rust
let a = true;
let b = ();
print!("{}", mem::size_of_val(&b));
```




## Mutable references

Semantics
- Aliases mutable data 
- Data can be modified through the created reference only
- Data that is owned by the referent can only be accessed through the mutable reference
- owning parents of the referent cannot be accessed

Syntax:
- `let mutable_reference = &mut v`


### Reference types

If you see a type parameter `T` then you know that 
- `T` is a super set of `&T` and `&mut T`
- `&T` is disjoint from `&mut T`


```rust
trait Trait {}
impl<T> Trait for T {}
impl<T> Trait for &T {} // ❌
impl<T> Trait for &mut T {} // ❌
```

## Pointers

Raw pointers are like references but do not have a lifetime or rules around borrowing.

Semantics
- a kind of reference that may point to invalid memory
  
Syntax
- mutable: `*mut`
- immutable: `*const`.
  
Disadvantages:
- Dereferencing of raw pointers has to happen in an unsafe environment

See:
- [question](https://stackoverflow.com/questions/4995899/difference-between-pointer-and-reference-in-c)
- [question](https://stackoverflow.com/questions/62232753/what-are-the-differences-between-a-pointer-and-a-reference-in-rust)

## Structs and fields

Synonyms
- classes
- objects
- records

Syntax
- `Struct`

Semantics
- defines a new type
- A collection of related fields for one entity

How to use fields:
- Don't assign the field:
  - `struct.field` will return a reference to the value of the field of the struct

```rust
fn main() {
    let my_box = MyStruct { field: 42 };

    // Explicitly dereferencing
    println!("{}", (*my_box).field); // This will also print 42
}
```

- Assign the field to a variable:
  - When assigning to a reference, the struct is borrowed
    - the struct can still be used afterwards
  - When assigning to an owned variable, 
    - the field is copy: the field is copied to the variable
    - the field is not copy: the struct is partially moved and
      - the struct becomes unusable after the assignment because it is then empty


If you assign a nonfield to a variable without creating a reference, you will move outside of the struct

```rust
fn main() {
    let my_struct = MyStruct { field: String::from("Hello") };

    // Accessing the field directly (returns a reference to the field)
    let field_ref: &String = &my_struct.field; // No move occurs here
    println!("{}", field_ref); // Prints: Hello

    // Trying to explicitly move the field out (will work)
    let moved_field = my_struct.field; // This will work and move the String
    println!("{}", moved_field); // Prints: Hello

    // At this point, `my_struct` cannot be used to access `field` anymore
    // println!("{}", my_struct.field); // This will cause a compile-time error
}
```

## Impl blocks

Synonyms
- class definitions
- method definitions

Semantics:
- group functions that are operating on a given struct
- cannot have overlapping `Self`

Syntax
- May have inline type bounds or inside a where clause
- Visible throughout the whole import and syntax tree

### Function pointers in methods 

#### Question

```rust
struct S {
    f: fn(),
}

impl S {
    fn f(&self) {
        print!("1");
    }
}

fn main() {
    let print2 = || print!("2");
    S { f: print2 }.f();
}
```

#### Short answer

```
1
```

#### Long answer

A call that looks like .f() always resolves to a method, in this case the inherent method S::f. To call the function pointer stored in field f, we would need to write parentheses around the field access: 

```rust
fn main() {
    let print2 = || print!("2");
    (S { f: print2 }.f)();
}
```

## Traits

synonyms
- typeclasses in Haskell

syntax
- trait

semantics
- Defines common behaviour between different types


### The goal of traits

They collect shared behaviours under a name.

What is shared behaviour? 

- Syntactically: 
  - A list of methods
  - use or reference one type of `self`
- Semantically: 
  - Things you can do with something
  - As minimal as possible
  - Not mutually exclusive with other sets of behaviour


### Inherent methods and priority


#### Question

```rust
trait Trait {
    fn f(&self);
    fn g(&self);
}

struct S;

impl S {
    fn f(&self) {
        print!("1");
    }

    fn g(&mut self) {
        print!("1");
    }
}

impl Trait for S {
    fn f(&self) {
        print!("2");
    }

    fn g(&self) {
        print!("2");
    }
}

fn main() {
    S.f();
    S.g();
}
```

#### Short answer

```
12
```

#### Long answer

S.f() calls the inherent method f. If an inherent method and a trait method have the same name and receiver type, plain method call syntax will always prefer the inherent method. The caller would need to write `Trait::f(&S)` or `<S as Trait>::f(&S)` in order to call the trait method.

On the other hand, S.g() calls the trait method g. Auto-ref during method resolution always prefers making something into & over making it into &mut where either one would work.

### Auto-ref

#### Question

https://dtolnay.github.io/rust-quiz/14

```rust 
trait Trait: Sized {
    fn is_reference(self) -> bool;
}

impl<'a, T> Trait for &'a T {
    fn is_reference(self) -> bool {
        true
    }
}

fn main() {
    match 0.is_reference() {
        true => print!("1"),
        false => print!("0"),
    }

    match '?'.is_reference() {
        true => print!("1"),
        false => {
            impl Trait for char {
                fn is_reference(self) -> bool {
                    false
                }
            }
            print!("0")
        }
    }
}
```

#### Short answer

```
10
```

#### Long answer

The method `is_reference` is not defined for integers, so the integer is automatically converted to a reference. The method exists for a reference, so it prints `1`. The nested `impl` block is visible everywhere, so `?` is printed as `0`. 

## Generic structs

Synonyms
- Generics in Python
- Templates in C++

Syntax
- a placeholder type parameter that has to be specified before methods can be called

Semantics
- a struct that for which the fields have different types based on the type parameter

Implementation
- The compiler applies monomorphization to code contain generics. Isn't this inefficient?
    - Improvement: define inner non-generic functions (Gjengset)



## Generic traits


Syntax
- traits that have type parameters.

```rust
trait Trait<T> {
    fn get_item(&self) -> T;
}
```

- In impl blocks first declare all the type parameters


Semantics
- add trait contraints



Examples

- `AsRef<T>`
- Custom traits

```rust
impl<T> Trait<T> for Struct<T> {
    fn get_item(&self) -> T {
        self.item
    }
}
```

Important

- Which type parameters should be declared at the beginning of the block and which should go in method declarations?
  - You should move type generic parameters to the declaration of the invididual functions if they only apply to a function. Otherwise you will get unconstraint type parameter compiler errors.

### Non-generic associated type traits

Semantics
- Useful for cases were there is a 1-to-1 relationship mapping from a generic type to its generic type parameters.
- In other words, there is only one type that fits in the hole of a type parameter for a given generic type.

Syntax

- You move the declaration of the type parameter below the name of the trait: 

```rust
trait Trait {
    type Item;
    
    fn get_item(&self) -> Self::Item;
    
}
```
- Then you can declare new functions that use this trait. 

```rust
fn get_item_from_trait<T: Trait>(t: T) -> T::Item {
  t.get_item()
}
```

Benefits
- You are not required to specify the particular instances for the chosen associated types, when you call something bounded by it
- You can assign names type arguments and use them when referencing the trait

Disadvantages
- Not all generic traits can be rewritten as traits with associated types.


Examples:

- Iterators
  - What are some useful iterator combinators?
- Futures
- Deref




## Generic traits with associated types




## Trait bounds

Trait bounds can be applied to type parameters. They constrain the possible input types. At compile time the compiler will try to compute concrete types that satisfy the trait bounds. 

### Where to write bounds

Trait bounds can appear in

- struct definitions
- trait definitions
- impl definitions

They can either appear

- inline: `GenericType<SomeGenericParameter: SomeTrait>`
- where clauses: `where SomeGenericParameter: SomeTrait`

### Supertraits

Semantics:
- Inherit methods from a more general trait

Syntax:
`pub trait SomeTrait: SuperTrait {}`



### Inheritance in Rust

You might want to replicate inheritance in Rust.

Since the only things that can inherit are traits, you might try to replace structs by traits.

This is wrong. Instead use:

- separate, differently constrained impl blocks
- traits with supertraits

An advantage of this approach is that trait bounds can be composed with `+`

### Fixing violated type bounds

If some type bound is not satisfied, the compiler will give an error.

How to fix the error:

- Are you in an impl block outside of a trait? 
  - Look at the contraints of the impl block.
    - They are in front of the impl block or behind in a where clause.
    - They are unordered, so do not verify the order
  - If you don't find any errors, verify the contraints of the struct.
    - Look at the order of the inline generic type parameters in the declaration
    - Look at the order the order of occurence of application of type generics in the impl. 
    - Look for a mismatched order.
    - Look in the where clauses around the struct for unsatisfied bounds. They are unordered.
    - Break down composed (with a +-sign) bounds and check them individually.
- Are you in an impl block in a trait?
  - Do the same.
  - Look at the constraints in the trait definition.
  - Look at the constraints imposed by supertrait bounds.

### Multi-threading bounds

Send
- definition: “safe to be move between threads” = thread safe
    - transfer ownership to other thread
    - other thread becomes responsible for dropping object
    - share a mutable reference to another thread
- automatically implemented by compiler based on some rules
- examples
    - which types are send?
        - Structs without references are Send + 'static
        - Structs with fields that are references with lower-bound lifetime parameter 'a are Send + 'a
        - Cell
    - Not send
        - `*mut T`
Sync
- definition: 
  - &T is Send.
- semantics
  - safe to access immutably from several threads in parallel
- Rules
  - Pointers are in one-to-one corresponds with pointers to pointers (&T = &TT). This implies that `T : Sync <=> &'_ T : Sync`.
      - A consequence of this is that if `T: !Sync` then `&'_ T: !Sync`
  - Examples:
    - Arc
  - Counterexamples
    - Rc is a reference pointing to an unsynchronized mutable handle Cell so not sync
    - RefCell.

  
### Combinations

https://stackoverflow.com/questions/68704717/is-the-sync-trait-a-strict-subset-of-the-send-trait-what-implements-sync-withou

Common combinations
- Send + !Sync: 
  - original !Sync type
  - Semantics:
    - may be accessed from any thread but only one at a time
- !Send + !Sync, 
  - Semantics:
    - types that manipulate shared handles to !Sync types
  - Examples
    - `Rc<T>` is such an example.
    - Raw pointers

Rare combination: 
- !Send + Sync:
  - Semantics
    - may be accessed immutably from any thread and multiple in parallel
    - mutable access has to happen on the thread it was created on
    - transferring a &mut T to another thread is not possible since it would break the protections that !Send has
  - Examples
    - MutexGuard of a T https://users.rust-lang.org/t/example-of-a-type-that-is-not-send/59835/3
      - cannot be dropped in a different thread, so it is not Send
      - If T is sync then it follows from `T : Sync ⇔ &'_ T : Sync` that a `MutexGuard<T>` is Sync

## Lifetime bounds

Structs or types can contain references. In that case they receive a lifetime parameter. 

Syntax:

- Structs: lifetime parameters are written before the generic type arguments. 
- Functions: lifetime parameters are written before the argument list 

Semantics:

- `T: 'a` You can hold on `T` 
  - for the lifetime `'a` 
  - until you move it out

Rules/corollary:

- `&'a T => T: 'a`, since a reference to T of lifetime 'a cannot be valid for 'a if T itself is not valid for 'a

Examples:

- `T: 'static`:
  - `T` does not contain any lifetimes
  - `T` is an owned variable

Quiz questions:

- What is the difference between `T : 'static` and `&'static T`?


## Lifetime bounds in methods

If you call a method on a struct that accesses a field and put it in a reference, the struct is borrowed for the duration of the reference to the field. 

Solution: create copies instead of borrowing a reference.


## Function traits

Semantics:
- Fn: functions that can be called infinitely and may reference variables
- FnMut: functions that may reference mutable variables
- FnOnce: functions that can only be called once and may move or drop variables

Rules:
- `Fn => FnMut => FnOnce`

## Function items

- syntax
  - created with `fn foo() {}`
  - `fn(u32) -> i32 {fn_name}` in error messages
- semantics
  - stateless, pure
   - can be transferred to other threads since there is no risk of data races
  - references to immutable code in compiled binary
    - can easily be cloned or copied  
    - can be optimized away `=>` no pointer needed `=>` zero sized
  - have unique unnameable types


```rust
fn my_function(x: i32) -> i32 {
    x + 1
}

fn main() {
    let f = my_function; // f is a function item (ZST)
    println!("Size of f: {}", std::mem::size_of_val(&f)); // Output: 0
}
```

## Function pointers

- Syntax
    - declared with `fn() -> ()`
    - not a trait
      - so not written with a capital letter.
      - cannot be used as a trait bound
- Semantics
  - Points to 
    - a top-level defined function item
    - an associated function
  - cannot capture from the environment
  - Implements all the following traits Fn, FnMut, and FnOnce
  - size of a pointer, has to be dereferenced,
    - might be slower than calling a function item or closure directly,
    - faster then dyn Fn
  - Primitive type, not a trait



```rust
fn my_function(x: i32) -> i32 {
    x + 1
}

fn main() {
    let f: fn(i32) -> i32 = my_function; // f is a function pointer
    println!("Size of f: {}", std::mem::size_of_val(&f)); // Output: 8 (on 64-bit)
}
```

- How can it be created?
    - non-capturing closures
    - function items with the same signature
- How can it be used?
  - Can be passed as argument to
    - function items
    - other function pointers
  - Can be returned from a function item


When is it particularly useful?
- When using FFI with languages that don't support closures


## Closures


- Alternative names
  - Lambda
- Semantics
  - A function defined in a certain scope that captures reference to variables in the containing scope
  - Creates an implicit struct to store captured data.
  - Has an implicit call method defined
- Syntax
  - Complete type cannot be written explicitly   

### Tuples versus grouping

#### Question

```rust
struct S(i32);

impl std::ops::BitAnd<S> for () {
    type Output = ();

    fn bitand(self, rhs: S) {
        print!("{}", rhs.0);
    }
}

fn main() {
    let f = || ( () & S(1) );
    let g = || { () & S(2) };
    let h = || ( {} & S(3) );
    let i = || { {} & S(4) };
    f();
    g();
    h();
    i();
}
```

#### Short Answer

The output will be 123

#### Long answer

```rust
let i = || {
    {}
    &S(4)
};
```
The combination of an inner and outer `{}`, makes the parser interpret the `{}` as an empty block statement followed by & as a reference. 



## Closures and lifetimes

Lifetime elision rules are different so the following does not compile 

```rust
fn main() {
    let closure = |x: &i32| x; // ❌
}
```

Beause it expands to

```rust 
fn main() {
    // input and output each get their own distinct lifetimes
    let closure = for<'a, 'b> |x: &'a i32| -> &'b i32 { x };
    // note: the above line is not valid syntax, but we need it for illustrative purposes
}
```

Two distinct lifetimes are created for the input and output type. For normal functions, only one lifetime is created.

## Closure implementations

How are they implemented? https://huonw.github.io/blog/2015/05/finding-closure-in-rust/

- the body block of the closure is analyzed
- variables in the body that refer to variables in the surrounding scope are Marked as captured
- struct generated at compile time with as fields the references to the captured variables, it serves as the environment for the closure body
  - the struct is invisible and out of reach for the programmer in normal Rust code
  - This makes closures part of the family of unnameable types (also called Voldemort types)

Disadvantages
- The exact type of a closure struct cannot be written out to type an input or output argument 

Solutions

- A trait object object has to be used

```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```

You can change the default behaviour to only create references to the surrounding environment. You can also move variables inside the struct representing the environment of the closure. This is done by using the move keyword.
- takes ownership of variables in the surrounding scope
- inside the closure the variables are used by reference
  - does not make the closure FnOnce in itself


## Variants of closures

There are different kinds of closures based on the signature of their call method on the underlying struct:
- Fn:
    - the signature is call(&self),
    - the body of the closure only may have
        - immutable references to its containing scope
        - values that were moved from the containing scope (and only use them by reference afterwards)
    - can be called from anywhere, multiple times
    - Must implement FnMut
- FnMut:
    - the signature is (& mut self)
    - the closure can have
        - mutable references to its containing scope
        - immutable references to its containing scope
    - cannot consume or move out captured variables
    - can be called more than once, but only once at a time, must implement FnOnce
- FnOnce
    - signature is call(self)
    - can only be called once
    - Can move variables that are moved in out
        - Other words:
            - consume captured variables
            - apply functions to them and call by value, not by reference
        - This means that it is not Fn or FnMut, because those should be able to be called multiple times
    - and mutate,
    - implemented by every closure
  - Only implement copy clone send and sync when their contents do

### Interpretation of the return keyword

#### Question

```rust
trait Trait {
    fn f(&self);
}

impl<F: FnOnce() -> bool> Trait for F {
    fn f(&self) {
        print!("1");
    }
}

impl Trait for () {
    fn f(&self) {
        print!("2");
    }
}

fn main() {
    let x = || { (return) || true; };
    x().f();
}
```

#### Short answer

This will output 2. Why?

#### Long answer

1. We define a closure x `|| { (return) || true; }`
2. `(return)` is of type `!` because it never completes
3. `(return) || true` is of type `! || true` which evaluates to `bool || true`
4. `bool || true;` evaluates to `()`
5. `f` is implemented for `()` to output `2`.

```rust

fn main() {
    let x = || { return || true; };
    x().f();
}
```
Will output 1 since a call to x returns another closure that returns a bool.


### Ranges and FnOnce

https://dtolnay.github.io/rust-quiz/33

#### Question
```rust
use std::ops::RangeFull;

trait Trait {
    fn method(&self) -> fn();
}

impl Trait for RangeFull {
    fn method(&self) -> fn() {
        print!("1");
        || print!("3")
    }
}

impl<F: FnOnce() -> T, T> Trait for F {
    fn method(&self) -> fn() {
        print!("2");
        || print!("4")
    }
}

fn main() {
    (|| .. .method())();
}
```

#### Short answer

In this case main would print 24.

#### Long answer

This code is parsed as 

1. `(|| ..).method()`
2. this an invocation of our impl of Trait on `FnOnce() -> T` where T is inferred to be RangeFull. 

## Type elision / erasure

Sometimes
- we don't know the type
  - the particular instance of a trait we exactly need as input or output for a function signature
  - the actual type is hidden from the user. These types are called unnameable or Voldemort types
- we know the type, but the full type is too long to be readable
  - iterator implementors
  - future combinators (see next session)


solution:
- For local variables 
  - use the wildcard `_`
- In type declarations for functions, traits or structs, 
  - the type cannot be inferred by the compiler
  - use opaque types

   
Benefits of opaque types
- hide specific types,
- cleaner API
- underlying concrete type can be an unnameable type
   

### Trait objects

First type of opaque types is a **trait object**:

- synonyms
  - dynamic dispatch
- syntax
  - Marked with the dyn keyword
- semantics
  - a pointer to an object
  - a pointer to a method table, called a **vtable** with function pointers for each method of the trait
- Disadvantages
  - Cannot be pushed on the stack directly, 
  - has to be on the heap or behind a pointer on the stack
  - Method call is determined at runtime, less optimizations
- How can it be created? Which traits can be used to create trait objects? The ones that are object safe.
    - cannot have generic methods
    - The return type isn't Self.


### Dynamic versus static dispatch

#### Question
What is the output of this Rust program?
```rust
trait Base {
    fn method(&self) {
        print!("1");
    }
}

trait Derived: Base {
    fn method(&self) {
        print!("2");
    }
}

struct BothTraits;
impl Base for BothTraits {}
impl Derived for BothTraits {}

fn dynamic_dispatch(x: &dyn Base) {
    x.method();
}

fn static_dispatch<T: Base>(x: T) {
    x.method();
}

fn main() {
    dynamic_dispatch(&BothTraits);
    static_dispatch(BothTraits);
}
```

#### Long answer 

- Dynamic dispatch: The forwarding is done by reading from a table of function pointers contained within the trait object. Expanded to `<dyn Base as Base>::method`. Since the argument was obtained by converting a BothTraits to dyn Base, the automatically generated implementation detail will wind up forwarding to `<BothTraits as Base>::method` which prints 1.
- Static dispatch: Type inference within generic functions in Rust happens independently of any concrete instantiation of the generic function i.e. before we know what T may be, other than the fact that it implements Base. By the time that T is decided, it has already been determined that x.method() is calling `<T as Base>::method` or `<BothTraits as Base>::method` which prints 1.

### Lifetimes for trait objects

https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md#6-boxed-trait-objects-dont-have-lifetimes

### DSTs

Trait objects are part of the family of dynamically sized types (DST) 

Synonyms
- unsized types
Syntax
- `GenericType<D: ?Sized>`
Semantics
- Types that don't fit on the stack as local variables by value

Examples
- slices: fat pointer has address and length
- trait objects:

Related concepts:
- References to DSTs are called **fat pointers.** https://stackoverflow.com/questions/57754901/what-is-a-fat-pointer

Counterexamples? Most types are not DSTs because their size is known at compile time.
- They implement the trait Sized
- DSTs don't implement Sized

### Impl trait

The other type of opaque types is impl Trait.

Synonyms
- anonymous types

syntax
- written `impl Trait` 
- syntax sugar for hardcoding a specific type that can be inferred by the compiler
- new lifetime capturing rules for return position impl traits? https://blog.rust-lang.org/2024/09/05/impl-trait-capture-rules.html
  - explicit capturing of specific or none of the lifetimes in the arguments
  - consequences: 
    - implementation can be changed 
    - but signature does not have to be changed

semantics
- No extra heap allocation
- No dynamic dispatch overhead

Implementation:
- "return position impl Trait" (RPIT) in Trait definitions (allowed since dec 2023)
  - the anonymous type in the impl T return type is a kind of associated type


## Co-operative vs pre-emptive multitasking

When a CPU has to accomodate for multiple threads (or more general tasks), it needs to have a way to switch between different tasks. This is called **context switching**.

- cooperative multitasking
  - process themselves say when they can't make progress
  - in practice context switching happens on yield points
- pre-emptive multitasking
  - context switching happens by force on arbitrary points 
  - could be useful when dealing with listeners in the UI for responsiveness if no yield points

See https://stackoverflow.com/questions/46015648/cooperative-scheduling-vs-preemptive-scheduling


## Coroutines

Synonyms:
- Generators

Semantics
- has a signature like a function and a closure
- can capture variables by reference or by value like closure
- can be suspended during execution
- can be resumed before final return


Syntax
- How can I write a coroutine

```rust
#![feature(coroutines, coroutine_trait, stmt_expr_attributes)]

use std::ops::Coroutine;
use std::pin::Pin;

fn main() {
    let mut coroutine = #[coroutine] || {
        println!("2");
        yield;
        println!("4");
    };

    println!("1");
    Pin::new(&mut coroutine).resume(());
    println!("3");
    Pin::new(&mut coroutine).resume(());
    println!("5");
}
```

A **generator** is a simple kind of coroutine:
- Used to generate values for a list
- does not receive information when resumed. Coroutines in general may receive information when they are resumed.
- not tied to an event loop

Advantages
- Can be used to write concurrent code
  -  more efficient code that is cooperative, yields control to the caller if an external event did not happen
- Can be used to write iterators

Benefits
- expensive threads can be replaced by coroutines: 
  - smaller and more efficient context switching
- might be an easier way to write iterators
- can be used to implement async
- Optimizing utilizing computational resources (registers, caches, cores, ...)
- Not necessarily but possibly parallel

See
- https://doc.rust-lang.org/beta/unstable-book/language-features/coroutines.html

## Types of coroutines

There are to types of implementations for coroutines:
- stackful
  - as functions are called as part of the coroutine, their frames are pushed on the stack
  - each coroutine has its own stack
  - more control over the execution state 
    - easier to handle deeply nested function calls
  - more memory heavy
    - context switching is slower
- stackless
  
  - only store resumption point in an enum with necessary variables
  - more memory efficient and faster
  - more complex to implement for nested calls
  - impossible to display stack in a debugger

See
- https://langdev.stackexchange.com/questions/697/what-are-the-benefits-of-stackful-vs-stackless-coroutines
- https://without.boats/blog/why-async-rust/

## Stackless coroutines

- How are they implemented in Rust? 

```rust
pub trait Coroutine<R = ()> {
    type Yield;
    type Return;
    fn resume(self: Pin<&mut Self>, resume: R) -> CoroutineState<Self::Yield, Self::Return>;
}
```
The `Coroutine` trait is implemented on an enum.
Enum variants represent states of a state machines.
At every yield, the captured variables have to be referenced.

```rust
enum __Coroutine {
    Start(&'static str),
    Yield1(&'static str),
    Done,
}
```

The resume method progresses the states of the state machine:

```rust
impl Coroutine for __Coroutine {
    type Yield = i32;
    type Return = &'static str;

    fn resume(mut self: Pin<&mut Self>, resume: ()) -> CoroutineState<i32, &'static str> {
        use std::mem;
        match mem::replace(&mut *self, __Coroutine::Done) {
            __Coroutine::Start(s) => {
                *self = __Coroutine::Yield1(s);
                CoroutineState::Yielded(1)
            }

            __Coroutine::Yield1(s) => {
                *self = __Coroutine::Done;
                CoroutineState::Complete(s)
            }

            __Coroutine::Done => {
                panic!("coroutine resumed after completion")
            }
        }
    }
}
```

Then we need to pin the coroutine, since it contains references and shouldn't be moved. 

```rust
Pin::new(&mut coroutine).resume(());
Pin::new(&mut coroutine).resume(());
```

- What is the meaning of the Pin type?

Disadvantage  
- unstable Rust language feature

See
- https://doc.rust-lang.org/beta/unstable-book/language-features/coroutines.html#coroutines-as-state-machines
- https://tmandry.gitlab.io/blog/posts/optimizing-await-1/
  

## Async-await

Semantics
- A computational model to deal efficiently with external events
  
Syntax  

```rust
use zenoh::prelude::r#async::*;

#[tokio::main]
async fn main() {
    let session = zenoh::open(config::default()).res().await.unwrap();
    session.put("key/expression", "value").res().await.unwrap();
    session.close().res().await.unwrap();
}
```

Advantages
- All the advantages from stackless coroutines such a more efficient multit-tasking
- Respond efficiently to network events

Disadvantages
- Cannot be mixed easily with synchronous code, colors functions
- Bounds have to be added explicitly to a desugared function signature using `impl Future`
 
See
- https://docs.rs/zenoh/latest/zenoh/

## Common async code patterns 

- How to create an asynchronous iterator?

See
- https://blog.yoshuawuyts.com/async-iterator-trait/
- https://github.com/Kobzol/async-iterator-examples/tree/main

### Async implementations

- `async fn` function declarations desugar to `impl Future` (RPIT)
- every `Future` is a stackless coroutine
- The `impl Future` captures all the lifetime variables, unless opted out

- Similarly to coroutines, inside a future
  - Local references or variables which are valid across await points are stored in a struct
  - A future can be send only if the internal data is send.

## Aynchronous functions as coroutines

If every function was a couroutine, you could put the different concepts in a table.

The following diagram comes from https://without.boats/blog/coroutines-async-and-iter/


|                | YIELDS               | RETURNS         | RESUMES         |
|----------------|----------------------|-----------------|-----------------|
|                |                      |                 |                 |
| BASE CASE      | `!`                  | `Self::Output`  | `()`            |
|                |                      |                 |                 |
| FUTURE         | `()`                 | `Self::Output`  | `&mut Context`  |
|                |                      |                 |                 |
| ITERATOR       | `Self::Item`         | `()`            | `()`            |
|                |                      |                 |                 |
| ASYNCITERATOR  | `Poll<Self::Item>`   | `()`            | `&mut Context`  |
|                |                      |                 |                 |


Explanation of table

- normal functions: considered as coroutines, don't yield, so the never type is used for yield. They resume type is only relevant for coroutines that yield, so it is empty for normal functions.
- futures: When a future is viewed as the state of a call to a coroutine, it's poll function is the function that resumes the coroutine. But to poll a future, you need pass the context which contains the waker. The waker is way to notify the async runtime, in case it is currently pending, that in the future the future is ready to be polled again.

## History of async

2013: Green threads are threads managed by a runtime in user-space and can be pre-emptive or cooperative. They make it possible to continue executing multiple tasks in parallel. 
2015: native threads: better for compatibility, less overhead
2016: Tokio, `Future` trait
2018: async/await syntax

[why-async-rust](https://without.boats/blog/why-async-rust/)

## Async runtimes

- How is an asynchronous runtime implemented? [https://tokio.rs/tokio/tutorial/async](https://tokio.rs/tokio/tutorial/async)
- Which asynchronous runtime should I use?

- Does an async runtime use many threads? Or does it create some kind of application level threads?

## Complex asynchronous applications

- When should I pin futures and store them?
- What's the best approach for handling structs with lifetimes in asynchronous or multithreaded code? Are there alternatives to avoiding them altogether?

## Cutting edge

- Async closures [https://blog.rust-lang.org/inside-rust/2024/08/09/async-closures-call-for-testing.html](https://blog.rust-lang.org/inside-rust/2024/08/09/async-closures-call-for-testing.html)
- async drop