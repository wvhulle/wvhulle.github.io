# Advanced Rust

https://dtolnay.github.io/rust-quiz/11

https://www.reddit.com/r/rust/s/dgNuFoGZ3r


## Types

Each variable in Rust has a type.

- What are the fundamental types in Rust?

There are also some more exotic types in Rust:

- General algebraic datatypes (GADTs)?
  - product types: tuples, structs
  - sum types: enums
  - combinations: 
    - enums with variants being structs
    - structs with fields being enums

Examples of types:
- Zero sized types

How to use types in Rust?

The body of functions exists of blocks.
A block is a sequence of 
- assignments
- expressions

The output variables of assignments in let expressions are owned by the surrounding block. The type of the variable becomes an "owned" type, owned by the surrounding block. 

The expression after the last semicolon in an inner block can assigned to a variable outside the blockis the return value of the block. This means that the owner of the last expression becomes the outer block.

Rust has an extra layer of information on top of types.

- Types in can be divided into two categories:
  - owning types: types that are owned by the current block
  - non-owning types: types that are not owned by the current block
    - mutably borrowed by a reference
    - immutably borrowed by a reference




## Ownership

### Owning variables

This type of variables become owner of the data as soon as the data is created through a declaration and an assignment. Owning variables are bound to a scope or expression and may pass ownership to a different scope, but as long as they have the ownership, they are responsible for destroying or de-initializing the data they refer to a the end of the scope.

Types of owning variables:

- normal local variables: Every programming language gives the ability to define names for data and allocate local variables on the stack for temporary storage.
- owning **smart pointers**: A more advanced version of normal variables. These are explicitly allocated on the heap.
  - Rust. The most basic example of a smart pointer in Rust is `Box`. This type gives a level of indirection by pointing to a location on the heap. A more complicated version is  `RefCell`, which enables some kind of locking so that no more than variable can modify the content at the same time. The multi-threaded version of `RefCell` is `Mutex`. A mutex is a programming concept that is frequently used to solve multi-threading problems. It is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.
  - C also has owning smart pointers such as mutexes.

### Non-owning variables

This type of variables are not an owner of the data. We say "they don't capture ownership". Ownership entails responsibility to clean up. Non-owning variables are not responsible for cleaning up data. The advantage of non-owning variables is that you can share data without copying, so they can increase the speed of your program.

They come in two types (see [question](https://stackoverflow.com/questions/62232753/what-are-the-differences-between-a-pointer-and-a-reference-in-rust)):


#### Pointers

A pointer is an address that points to a different point in memory. A pointer takes up extra space, on top of the data at the destination. The declaration of a pointer entails the allocation of some empty space in memory which makes it a run-time feature (see [question](https://stackoverflow.com/questions/4995899/difference-between-pointer-and-reference-in-c)). It may be created on the stack or the heap and usually takes the space of the size of a register on the CPU, which may be 32 or 64 bit.

**Special for Rust**: Raw pointers are like references but do not have a lifetime. They do not have any kind of access control or compile-time borrowing rules imposed.

Types of pointers:

- raw pointers: This type of pointer is usually created on the stack. Such pointers may be pointing to an invalid memory region, memory that contains invalid or no data.
  - mutable: This type of pointers can be used to update the data at the target address.
    - Rust: A mutable raw pointer in Rust is written `*mut`. It is used mostly in unsafe code, code that works with raw pointers.  Rust has a special `unsafe` environment to work with raw pointers.
    - C: `char* p = &c`. C also has the famous `NULL` pointer which leads to many problems, since every pointer is mutable by default and can be the `NULL` pointer.
  - immutable:  This type of pointer cannot be used to update the data at the target address.
    - Rust: immutable pointers are declared with `*const`.
- (non-owning) **smart pointers**: created on the heap, may not point to invalid memory.
  - Rust: The data `Arc` gives the ability to share ownership with multiple pointers. New pointers can be created by cloning the `Arc`. When no pointers remain that point to the data anymore, the reference count becomes zero and the data is de-allocated. This is called *reference counting*. Reference counting is the default way to share data in standard garbage-collected dynamic languages.
  - C++: Also has a kind of smart pointers. See for example the analogue of `Arc` called `shared_ptr` (see [smart pointers in c++](https://www.geeksforgeeks.org/smart-pointers-cpp/)).


#### References as aliases

An alias for a piece of data, does not take up extra space, cannot be re-initialized. A reference can be dropped, which is usually done at the end of the scope. A reference is a *borrow*. Using references in Rust is called *borrowing* data.

**Special for Rust**: A reference in Rust is any variable that implements the `Deref` trait (which is a kind of type class or interface). This means that it needs to have a *dereferencing* operation implemented. In Rust, references also have a life time (a time over which they are valid) and cannot capture ownership (they do not become responsible for cleaning up data). Life-times are annoted with the special syntax `&'a x` with a single quote. Rust has special borrow rules that distinguish immutable from mutable borrows, see below.

Types of references:

- immutable: used when we want to read data but not change it, checked at compile-time, so has the best performance.
  - Rust:  An immutable reference does not steal acces, so this allows for sharing of data in a larger programs between different components. After a reference is created, you can follow it by writing the dereference operator `*`. The address of a reference can be printed with `println!("{:p}", &1);`.
  - C: `const char& r = c`, does not steal access.
- mutable: exclusive access to data, written as
  - Rust: You can create an immutable reference by prefixing a variable with `&`: `let a = &b`, steals the access to some data while the mutable reference is valid.
  - C: `char& r = c`, does not steal access.
  - Python: alternative variable names for data.


Questions:
- Does using * on a reference transfer the ownership? Why does it not?



## Lifetimes

- What are the lifetime parameter elision rules? See https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md

- What is the meaning of &'static T?


## Structs


- How is the Deref trait implemented for fields of structs?

- Impl blocks
    - Why is it sometimes impossible to call a method with a signature (&self), assign it to something and then later try to use &self again?
    - Which type parameters should be declared at the beginning of the block and which should go in method declarations?


## Impl blocks



## Traits


- synonyms
  - typeclasses in Haskell
- syntax
  - trait
- semantics
  - Defines common behaviour between different types
  


When implementing traits the first keywords behind the impl block are the generic type parameters that apply to the type for which functions are being implemented. They are fixed from the creation of the type. Similarly for lifetime parameters. You should move type generic parameters to the declaration of the invididual functions if they only apply to a function.


### Common traits

Iterators:

- What are some useful iterator combinators?



### Associated types

- What are associated types?
  - For a given type Self, there can only be one implementation of a non-generic trait, which implies there can only be one concrete type per associated type of a non-generic trait

- When should you use associated types
  - easier to work with, since no type annotations have to be used to give concrete types to the trait and call a specific implementation of possibly multiple implementations
  - good for example when implementing particular traits
    - iterator trait (only one possible item type)
    - future trait (there is only one possible output type)


## Generic programming

- Generic types are structs or traits with a placeholder type parameter that has to be specified before methods can be called
    - The compiler applies monomorphization to code contain generics. Isn't this inefficient?
    - Improvement: define inner non-generic functions (Gjengset)

## Trait bounds

### Reference traits

Deref

AsRef


### Multi-threading bounds

Send
- definition: “safe to be move between threads” = thread safe
    - transfer ownership to other thread
    - other thread becomes responsible for dropping object
    - share a mutable reference to another thread
- automatically implemented by compiler based on some rules
- examples
    - which types are send?
        - Structs without references are Send + 'static
        - Structs with fields that are references with lower-bound lifetime parameter 'a are Send + 'a
        - Cell
    - Not send
        - `*mut T`
Sync
- definition: 
  - &T is Send.
- semantics
  - safe to access immutably from several threads in parallel
- Rules
  - Pointers are in one-to-one corresponds with pointers to pointers (&T = &TT). This implies that `T : Sync <=> &'_ T : Sync`.
      - A consequence of this is that if `T: !Sync` then `&'_ T: !Sync`
  - Examples:
    - Arc
  - Counterexamples
    - Rc is a reference pointing to an unsynchronized mutable handle Cell so not sync
    - RefCell.

  
### Combinations

https://stackoverflow.com/questions/68704717/is-the-sync-trait-a-strict-subset-of-the-send-trait-what-implements-sync-withou

Common combinations
- Send + !Sync: 
  - original !Sync type
  - Semantics:
    - may be accessed from any thread but only one at a time
- !Send + !Sync, 
  - Semantics:
    - types that manipulate shared handles to !Sync types
  - Examples
    - `Rc<T>` is such an example.
    - Raw pointers

Rare combination: 
- !Send + Sync:
  - Semantics
    - may be accessed immutably from any thread and multiple in parallel
    - mutable access has to happen on the thread it was created on
    - transferring a &mut T to another thread is not possible since it would break the protections that !Send has
  - Examples
    - MutexGuard of a T https://users.rust-lang.org/t/example-of-a-type-that-is-not-send/59835/3
      - cannot be dropped in a different thread, so it is not Send
      - If T is sync then it follows from `T : Sync ⇔ &'_ T : Sync` that a `MutexGuard<T>` is Sync

## Lifetime bounds

Structs or types can contain references. In that case they receive a lifetime parameter. 

Syntax:

- Structs: lifetime parameters are written before the generic type arguments. 

Semantics:

- `T: 'a` You can hold on `T` 
  - for the lifetime `'a` 
  - until you move it out

Rules/corollary:

- `&'a T => T: 'a`, since a reference to T of lifetime 'a cannot be valid for 'a if T itself is not valid for 'a

Examples:

- `T: 'static`:
  - `T` does not contain any lifetimes
  - `T` is an owned variable

Quiz questions:

- What is the difference between `T : 'static` and `&'static T`?

## Function traits

Semantics:
- Fn
- FnMut
- FnOnce

Rules:
- `Fn => FnMut => FnOnce`


## Function items

- syntax
  - created with `fn foo() {}`
  - `fn(u32) -> i32 {fn_name}` in error messages
- semantics
  - stateless, pure
   - can be transferred to other threads since there is no risk of data races
  - references to immutable code in compiled binary
    - can easily be cloned or copied  
    - can be optimized away `=>` no pointer needed `=>` zero sized
  - have unique unnameable types


```rust
fn my_function(x: i32) -> i32 {
    x + 1
}

fn main() {
    let f = my_function; // f is a function item (ZST)
    println!("Size of f: {}", std::mem::size_of_val(&f)); // Output: 0
}
```

## Function pointers

- Syntax
    - declared with fn() → ()
    - not a trait
      - so not written with a capital letter.
      - cannot be used as a trait bound
- Semantics
  - Points to 
    - a top-level defined function item
    - an associated function
  - cannot capture from the environment
  - Implements all the following traits Fn, FnMut, and FnOnce
  - size of a pointer, has to be dereferenced,
    - might be slower than calling a function item or closure directly,
    - faster then dyn Fn
  - Primitive type, not a trait



```rust
fn my_function(x: i32) -> i32 {
    x + 1
}

fn main() {
    let f: fn(i32) -> i32 = my_function; // f is a function pointer
    println!("Size of f: {}", std::mem::size_of_val(&f)); // Output: 8 (on 64-bit)
}
```

- How can it be created?
    - non-capturing closures
    - function items with the same signature
- How can it be used?
  - Can be passed as argument to
    - function items
    - other function pointers
  - Can be returned from a function item


When is it particularly useful?
- When using FFI with languages that don't support closures


## Closures

See [https://huonw.github.io/blog/2015/05/finding-closure-in-rust/](https://huonw.github.io/blog/2015/05/finding-closure-in-rust/)

- Alternative names
  - Lambda
- Semantics
  - A function defined in a certain scope that captures reference to variables in the containing scope
  - Creates an implicit struct to store captured data.
  - Has an implicit call method defined
- Syntax
  - Complete type cannot be written explicitly
      - because its real type at compile time is a complicated struct
      - This gives makes them part of the family of unnameable types (also called Voldemort types)
      - A trait object object has to be used
      
      ```rust
      fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
          Box::new(|x| x + 1)
      }
      ```
      
  - move keyword
      - takes ownership of variables in the surrounding scope
      - inside the closure the variables are used by reference
      - does not make the closure FnOnce in itself
- How can they be used?
  - There are different kinds of closures based on the signature of their call method:
      - Fn:
          - the signature is call(&self),
          - the body of the closure only may have
              - immutable references to its containing scope
              - values that were moved from the containing scope (and only use them by reference afterwards)
          - can be called from anywhere, multiple times
          - Must implement FnMut
      - FnMut:
          - the signature is (& mut self)
          - the closure can have
              - mutable references to its containing scope
              - immutable references to its containing scope
          - cannot consume or move out captured variables
          - can be called more than once, but only once at a time, must implement FnOnce
      - FnOnce
          - signature is call(self)
          - can only be called once
          - Can move variables that are moved in out
              - Other words:
                  - consume captured variables
                  - apply functions to them and call by value, not by reference
              - This means that it is not Fn or FnMut, because those should be able to be called multiple times
          - and mutate,
          - implemented by every closure
  - Only implement copy clone send and sync when their contents do

## Type elision / erasure

- Sometimes we
    - don't know which instance of a trait we exactly need  as input or output of a function
    - or it is too cumbersome to write out the full type
        - iterator implementors
        - future combinators (see next session)
    - the actual type is hidden from the user
        - Also called unnameable or Voldemort types
- For local variables in functions we can use the wildcard `_`


When the type cannot be inferred automatically by the compiler, we can use opaque types
    - benefits
        - hide specific types,
        - cleaner API
        - underlying concrete type can be an unnameable type

### Trait objects

First type of opaque types is a **trait object**:

- synonyms
  - dynamic dispatch
- syntax
  - Marked with the dyn keyword
- semantics
  - a pointer to an object
  - a pointer to a method table, called a **vtable** with function pointers for each method of the trait
- Disadvantages
  - Cannot be pushed on the stack directly, 
  - has to be on the heap or behind a pointer on the stack
  - Method call is determined at runtime, less optimizations
- How can it be created? Which traits can be used to create trait objects? The ones that are object safe.
    - cannot have generic methods
    - The return type isn't Self.

### DSTs

Trait objects are part of the family of dynamically sized types (DST) 

Synonyms
- unsized types
Syntax
- `GenericType<D: ?Sized>`
Semantics
- Types that don't fit on the stack as local variables by value

Examples
- slices: fat pointer has address and length
- trait objects:

Related concepts:
- References to DSTs are called **fat pointers.** https://stackoverflow.com/questions/57754901/what-is-a-fat-pointer

Counterexamples? Most types are not DSTs because their size is known at compile time.
- They implement the trait Sized
- DSTs don't implement Sized



### Impl trait

The other type of opaque types is impl Trait.
- syntax
  - written `impl Trait` 
  - sugar for hardcoding a specific type that can be inferred by the compiler
- semantics
    - No heap allocation
    - No dynamic dispatch overhead

Implementation of Return position impl A (RPIT) in Trait definitions
    - the anonymous type in the impl A return type is a kind of associated type

Timeline
- dec 2023: in traits
- sep 2024: 
  - new lifetime capturing rules for return position impl traits? https://blog.rust-lang.org/2024/09/05/impl-trait-capture-rules.html
    - explicit capturing of specific or none of the lifetimes in the arguments
    - consequences: 
      - implementation can be changed 
      - but signature does not have to be changed


## Async-await

- Syntax  
  - Desugars to impl future
  - when async function signatures is used in a trait it is syntax sugar for an RPIT
  - Which bounds are added to the impl Future output type?
- Semantics
  - Concurrent programming
  - Optimizing utilizing computational resources (registers, caches, cores, ...)
  - Not necessarily parallel
- Use cases
  - What are the benefits of asynchronous code?


- What's the best approach for handling structs with lifetimes in asynchronous or multithreaded code? Are there alternatives to avoiding them altogether?
 

### Built-in async traits

https://without.boats/blog/poll-next/

- What are some practical applications of asynchronous iterators?

### Async implementations

[why-async-rust](https://without.boats/blog/why-async-rust/)

- How are asynchronous function implemented?
- What are futures?
- How are references managed across await points in async functions? Where and how are they stored?
- What is the meaning of the Pin type?
- As with every impl Future output type in the new version of Rust, it will captures all lifetime constraints on the arguments. Up until now, a special hack was needed for this.


## Coroutines

Syntax
- How can I write a coroutine
Semantics
- cooperative multitasking
- What are coroutines https://doc.rust-lang.org/beta/unstable-book/language-features/coroutines.html


Questions:
- What is the difference between a coroutine and a generator
- what is the difference with a green thread?
- What is the difference between stackful and stackless coroutines?

Applications
- How can I write an iterator with a coroutine?

### Stackless couroutines


- What are stackless coroutines?
- How are they implemented in Rust? 
  - See
    - https://doc.rust-lang.org/beta/unstable-book/language-features/coroutines.html#coroutines-as-state-machines
    - https://tmandry.gitlab.io/blog/posts/optimizing-await-1/
  - State machines, just like future state machines.
- benefits  
  - no need to create separate stacks per coroutine




## Relationships

If every function was a couroutine, you could put the different concepts in a table.

The following diagram comes from https://without.boats/blog/coroutines-async-and-iter/


```txt
                  │   YIELDS            │   RETURNS       │   RESUMES
    ──────────────┼─────────────────────┼─────────────────┼─────────────────
                  │                     │                 │      
        BASE CASE │   !                 │   Self::Output  │   ()
                  │                     │                 │      
           FUTURE │   ()                │   Self::Output  │   &mut Context
                  │                     │                 │      
         ITERATOR │   Self::Item        │   ()            │   ()   
                  │                     │                 │      
    ASYNCITERATOR │   Poll<Self::Item>  │   ()            │   &mut Context
                  │                     │                 │      
```

Explanation of table

- normal functions: considered as coroutines, don't yield, so the never type is used for yield. They resume type is only relevant for coroutines that yield, so it is empty for normal functions.
- futures: When a future is viewed as the state of a call to a coroutine, it's poll function is the function that resumes the coroutine. But to poll a future, you need pass the context which contains the waker. The waker is way to notify the async runtime, in case it is currently pending, that in the future the future is ready to be polled again.

- The implementation of Rust async functions is very similar to the implementation of stackless coroutines.

## Tasks

## Runtimes

- How is an asynchronous runtime implemented? [https://tokio.rs/tokio/tutorial/async](https://tokio.rs/tokio/tutorial/async)
- Which asynchronous runtime should I use?

- Does an async runtime use many threads? Or does it create some kind of application level threads?

## Complex asynchronous applications

- When should I pin futures and store them?


## Cutting edge

- Async closures [https://blog.rust-lang.org/inside-rust/2024/08/09/async-closures-call-for-testing.html](https://blog.rust-lang.org/inside-rust/2024/08/09/async-closures-call-for-testing.html)
- async drop