# Advanced Rust

https://dtolnay.github.io/rust-quiz/11

https://www.reddit.com/r/rust/s/dgNuFoGZ3r


## Types


There are also some more exotic types in Rust:

- General algebraic datatypes (GADTs)?
  - product types: tuples, structs
  - sum types: enums
  - combinations: 
    - enums with variants being structs
    - structs with fields being enums

Examples of types:
- Zero sized types


Related in other languages:
- Fundamental types in Rust are similar to C++

## Basic operators

Question:

```rust
fn main() {
    let mut x = 4;
    --x;
    print!("{}{}", --x, --x);
}
```

no unary increment or decrement operator in Rust

## Scope allocation

Semantics
- Local variable assignments allocate data on the stack
- The data remains allocated until the end of the scope
- At the end of the scope of the variable, data is deallocated

Syntax
- A scope is delimited by curly braces

Examples
- code that locks a mutex essentially includes the logic that the lock will be released when execution leaves the scope of the object

Synonyms
- With blocks in Python and file handles
- in C++: Resource Acquisition Is Initialization (RAII)


Question:
What is the output of this Rust program?

```rust
use std::fmt::{self, Display};

struct S;

impl Display for S {
    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        formatter.write_str("1")
    }
}

impl Drop for S {
    fn drop(&mut self) {
        print!("2");
    }
}

fn f() -> S {
    S
}

fn main() {
    let S = f();
    print!("{}", S);
}
```

This program prints 212.

No value of type S gets dropped within the body of function f. The function f conjures an S and returns ownership of it to the caller of f; the caller determines when to drop the S of which it received ownership.

On the first line of main, we call f() and perform an infallible match that binds no new variables. As no variables are declared on this line, there is no variable that could be the owner of the S returned by f() so that S is dropped at that point, printing 2. The S in let S = f() is a unit struct pattern (not a variable name) that matches a value of type S via destructuring but does not bind the value to any variable.

The second line of main conjures a new S, prints it, and drops it at the semicolon.

## Ownership

Synonyms:
- Object lifetime

Semantics
- an extension of scope based resource management
- inside blocks and expressions, there are two categories of variables, members and fields:
  - owning types: 
    - types that are owned by the current block
    - Owning variables are bound to a scope
    - may pass ownership to a different scope
    - as long as they have the ownership, they are responsible for destroying or de-initializing the data they refer to a the end of the scope
  - non-owning types: types that are not owned by the current block
- ownership is also applied to nested data structures
- The owner can be moved without moving his children

Syntax:
- Invisible when created
- Visible in the error messages 
  - when trying to use a variable that has been moved

Consequences:
- Every piece of data in Rust has an owner
- The root owner is a code block
- Ownership relationship forms disjoint trees


## Root ownership 

Semantics
- The roots of the ownership tree are locally declared variables inside blocks. 
- Declared local variables are owned by the surrounding block. 
- Local variables are the top-most "owned" type

Implementation
- on the stack

Syntax:
- With `let`: locally declared variables

Examples:
- arrays
- numbers
- characters

## Ownership indirection

Semantics
- local variables can own data on the heap
- data on the heap can own other data on the heap
- gives a level of indirection, 
- ownership relationships between children of the ownership tree

Examples
- A vector points to and owns a buffer on the heap, it indirectly owns the value at each index.
- A struct owns the values of each field
- An enum variant owns the values of each field
- **smart pointers**: container types that own data that is allocated on the heap.
  - A `Box` 
  - A more complicated version is  `RefCell`, which enables some kind of locking so that no more than variable can modify the content at the same time. 
  - The multi-threaded version of `RefCell` is `Mutex`. A mutex is a programming concept that is frequently used to solve multi-threading problems. It is a synchronization primitive that can be used to protect shared data from being simultaneously accessed by multiple threads.
  
Related:
- C also has owning smart pointers such as mutexes.

## Moving ownership

Semantics:
- Transfer the ownership of allocated data to another place in the program
- The original location of the ownership parent is deallocated

Syntax:
- Invisible

Implementation
- Moving data that is owner of some other data will not move all its children in memory
- Only a Shallow copy is made

Examples:
- Moving through assignment
- Moving through assignment of blocks: transfers ownership of the variable associated with the last expression to the outer block
- Moving through capturing
  - Capture by constructors
  - Capture by functions

Related:
- In C++ a deep copy is made when assigning owning expressions


```rust
struct S;

impl Drop for S {
    fn drop(&mut self) {
        print!("1");
    }
}

fn main() {
    let s = S;
    let _ = s;
    print!("2");
}
```

In fact s does not get moved and the output is 21.

### Non-owning data

Semantics:
- Data that points to data that is owned by another parent
- "they don't capture ownership".
- Since only the owner has to clean up, non-owning data is not responsible for cleaning up the data being pointed to

Syntax
- Usually with the `&` sign

Advantages:
- You can share data without copying, so they can increase the speed of your program.

Examples:
They come in two types (see [question](https://stackoverflow.com/questions/62232753/what-are-the-differences-between-a-pointer-and-a-reference-in-rust)):
- pointers
- references


#### Pointers

A pointer is an address that points to a different point in memory. A pointer takes up extra space, on top of the data at the destination. The declaration of a pointer entails the allocation of some empty space in memory which makes it a run-time feature (see [question](https://stackoverflow.com/questions/4995899/difference-between-pointer-and-reference-in-c)). It may be created on the stack or the heap and usually takes the space of the size of a register on the CPU, which may be 32 or 64 bit.

**Special for Rust**: Raw pointers are like references but do not have a lifetime. They do not have any kind of access control or compile-time borrowing rules imposed.

Types of pointers:

- raw pointers: This type of pointer is usually created on the stack. Such pointers may be pointing to an invalid memory region, memory that contains invalid or no data.
  - mutable: This type of pointers can be used to update the data at the target address.
    - Rust: A mutable raw pointer in Rust is written `*mut`. It is used mostly in unsafe code, code that works with raw pointers.  Rust has a special `unsafe` environment to work with raw pointers.
    - C: `char* p = &c`. C also has the famous `NULL` pointer which leads to many problems, since every pointer is mutable by default and can be the `NULL` pointer.
  - immutable:  This type of pointer cannot be used to update the data at the target address.
    - Rust: immutable pointers are declared with `*const`.
- (non-owning) **smart pointers**: created on the heap, may not point to invalid memory.
  - Rust: The data `Arc` gives the ability to share ownership with multiple pointers. New pointers can be created by cloning the `Arc`. When no pointers remain that point to the data anymore, the reference count becomes zero and the data is de-allocated. This is called *reference counting*. Reference counting is the default way to share data in standard garbage-collected dynamic languages.
  - C++: Also has a kind of smart pointers. See for example the analogue of `Arc` called `shared_ptr` (see [smart pointers in c++](https://www.geeksforgeeks.org/smart-pointers-cpp/)).


#### References as aliases

An alias for a piece of data, does not take up extra space, cannot be re-initialized. A reference can be dropped, which is usually done at the end of the scope. A reference is a *borrow*. Using references in Rust is called *borrowing* data.

**Special for Rust**: A reference in Rust is any variable that implements the `Deref` trait (which is a kind of type class or interface). This means that it needs to have a *dereferencing* operation implemented. Rust has special borrow rules that distinguish immutable from mutable borrows, see below.

Types of references:

- immutable: used when we want to read data but not change it, checked at compile-time, so has the best performance.
  - Rust:  An immutable reference does not steal acces, so this allows for sharing of data in a larger programs between different components. After a reference is created, you can follow it by writing the dereference operator `*`. The address of a reference can be printed with `println!("{:p}", &1);`.
  - C: `const char& r = c`, does not steal access.
- mutable: exclusive access to data, written as
  - Rust: You can create an immutable reference by prefixing a variable with `&`: `let a = &b`, steals the access to some data while the mutable reference is valid.
  - C: `char& r = c`, does not steal access.
  - Python: alternative variable names for data.


## Borrowed variables

Data for which exist borrows or references, is called borrowed data. Borrowed data can not be moved. In other words, the owner can not be changed. Since moves can happen at function boundaries, special care is needed when returning data that is borrowed or borrows.

## Dereferencing 


The dereference operator `*` can appear on two sides of an assignment:

- On the left of an assignment 
  - can be used to update the value pointed to by a mutable reference if that value is declared mutable
- On the right of an assignent: accesses the value behind a reference
  - for references that point to copy types it will create a copy and assignment to the left 
    - types such as integers
  - for references that point to non-copy types, it will create a compile time error, since the ownership can not be moved through a reference

## Lifetimes

Synonyms:
- Which other programming languages support lifetimes?

Syntax:
- `'a`

Semantics:
- The lifetime of a reference. The logical timeframe within your program that a reference is valid. 
- Cannot shrink or grow

Usage:
- Lifetimes can be elided or omitted? See https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md
- When elided, the compiler will choose the shortest lifetime based on all the code paths.

Recommendations
- Give meaningful names to lifetimes

Quiz questions:
- What is the meaning of `&'static T`?


## Structs and fields

Synonyms
- classes
- objects
- records

Syntax
- `Struct`

Semantics
- defines a new type
- A collection of related fields for one entity

How to use fields:
- Don't assign the field:
  - `struct.field` will return a reference to the value of the field of the struct

```rust
fn main() {
    let my_box = MyStruct { field: 42 };

    // Explicitly dereferencing
    println!("{}", (*my_box).field); // This will also print 42
}
```

- Assign the field to a variable:
  - When assigning to a reference, the struct is borrowed
    - the struct can still be used afterwards
  - When assigning to an owned variable, 
    - the field is copy: the field is copied to the variable
    - the field is not copy: the struct is partially moved and
      - the struct becomes unusable after the assignment because it is then empty


If you assign a nonfield to a variable without creating a reference, you will move outside of the struct

```rust
fn main() {
    let my_struct = MyStruct { field: String::from("Hello") };

    // Accessing the field directly (returns a reference to the field)
    let field_ref: &String = &my_struct.field; // No move occurs here
    println!("{}", field_ref); // Prints: Hello

    // Trying to explicitly move the field out (will work)
    let moved_field = my_struct.field; // This will work and move the String
    println!("{}", moved_field); // Prints: Hello

    // At this point, `my_struct` cannot be used to access `field` anymore
    // println!("{}", my_struct.field); // This will cause a compile-time error
}
```

## Defining methods


Synonyms
- methods
Syntax
- Impl blocks

```rust
struct S {
    f: fn(),
}

impl S {
    fn f(&self) {
        print!("1");
    }
}

fn main() {
    let print2 = || print!("2");
    S { f: print2 }.f();
}
```

A call that looks like .f() always resolves to a method, in this case the inherent method S::f. To call the function pointer stored in field f, we would need to write parentheses around the field access: 

```rust
fn main() {
    let print2 = || print!("2");
    (S { f: print2 }.f)();
}
```

## Traits

synonyms
- typeclasses in Haskell

syntax
- trait

semantics
- Defines common behaviour between different types


```rust
trait Trait {
    fn f(&self);
    fn g(&self);
}

struct S;

impl S {
    fn f(&self) {
        print!("1");
    }

    fn g(&mut self) {
        print!("1");
    }
}

impl Trait for S {
    fn f(&self) {
        print!("2");
    }

    fn g(&self) {
        print!("2");
    }
}

fn main() {
    S.f();
    S.g();
}
```

S.f() calls the inherent method f. If an inherent method and a trait method have the same name and receiver type, plain method call syntax will always prefer the inherent method. The caller would need to write `Trait::f(&S)` or `<S as Trait>::f(&S)` in order to call the trait method.

On the other hand, S.g() calls the trait method g. Auto-ref during method resolution always prefers making something into & over making it into &mut where either one would work.

## Generic structs

Synonyms
- Generics in Python
- Templates in C++

Syntax
- a placeholder type parameter that has to be specified before methods can be called

Semantics
- a struct that for which the fields have different types based on the type parameter

Implementation
- The compiler applies monomorphization to code contain generics. Isn't this inefficient?
    - Improvement: define inner non-generic functions (Gjengset)

If you see a type parameter `T` then you know that 
- `T` is a super set of `&T` and `&mut T`
- `&T` is disjoint from `&mut T`


```rust
trait Trait {}
impl<T> Trait for T {}
impl<T> Trait for &T {} // ❌
impl<T> Trait for &mut T {} // ❌
```

## Generic traits


Syntax
- traits that have type parameters.

```rust
trait Trait<T> {
    fn get_item(&self) -> T;
}
```

- In impl blocks first declare all the type parameters


Semantics
- add trait contraints



Examples

- `AsRef<T>`
- Custom traits

```rust
impl<T> Trait<T> for Struct<T> {
    fn get_item(&self) -> T {
        self.item
    }
}
```

Important

- Which type parameters should be declared at the beginning of the block and which should go in method declarations?
  - You should move type generic parameters to the declaration of the invididual functions if they only apply to a function.




### Non-generic associated type traits


Syntax

- To declare

```rust
trait Trait {
    type Item;
    fn get_item(&self) -> Self::Item;
}
```

- To use 

```rust
fn get_item_from_trait<T: Trait>(t: T) -> T::Item {
    t.get_item()
}
```

Semantics
- For a given type Self, there can only be one implementation of a non-generic trait, which implies there can only be one concrete type per associated type of a non-generic trait
- The trait being implemented depends on a type parameter that is fixed accross all implementations


Examples:

- Iterators
  - What are some useful iterator combinators?
- Futures
- Deref

Disadvantages
- Not all generic traits can be rewritten as traits with associated types, but sometimes it is possible and they become cleaner. 

Benefits
- easier to work with, since no type annotations have to be used to give concrete types to the trait and call a specific implementation of possibly multiple implementations

## Generic traits with associated types

```rust
struct S(i32);

impl std::ops::BitAnd<S> for () {
    type Output = ();

    fn bitand(self, rhs: S) {
        print!("{}", rhs.0);
    }
}

fn main() {
    let f = || ( () & S(1) );
    let g = || { () & S(2) };
    let h = || ( {} & S(3) );
    let i = || { {} & S(4) };
    f();
    g();
    h();
    i();
}
```
123

```rust
let i = || {
    {}
    &S(4)
};
```
The combination of an inner and outer {}, makes the parser interpret the {} as an empty block statement followed by & as a reference. 


## Trait bounds

Trait bounds can be applied to type parameters. They constrain the possible input types. At compile time the compiler will try to compute concrete types that satisfy the trait bounds. 



### Multi-threading bounds

Send
- definition: “safe to be move between threads” = thread safe
    - transfer ownership to other thread
    - other thread becomes responsible for dropping object
    - share a mutable reference to another thread
- automatically implemented by compiler based on some rules
- examples
    - which types are send?
        - Structs without references are Send + 'static
        - Structs with fields that are references with lower-bound lifetime parameter 'a are Send + 'a
        - Cell
    - Not send
        - `*mut T`
Sync
- definition: 
  - &T is Send.
- semantics
  - safe to access immutably from several threads in parallel
- Rules
  - Pointers are in one-to-one corresponds with pointers to pointers (&T = &TT). This implies that `T : Sync <=> &'_ T : Sync`.
      - A consequence of this is that if `T: !Sync` then `&'_ T: !Sync`
  - Examples:
    - Arc
  - Counterexamples
    - Rc is a reference pointing to an unsynchronized mutable handle Cell so not sync
    - RefCell.

  
### Combinations

https://stackoverflow.com/questions/68704717/is-the-sync-trait-a-strict-subset-of-the-send-trait-what-implements-sync-withou

Common combinations
- Send + !Sync: 
  - original !Sync type
  - Semantics:
    - may be accessed from any thread but only one at a time
- !Send + !Sync, 
  - Semantics:
    - types that manipulate shared handles to !Sync types
  - Examples
    - `Rc<T>` is such an example.
    - Raw pointers

Rare combination: 
- !Send + Sync:
  - Semantics
    - may be accessed immutably from any thread and multiple in parallel
    - mutable access has to happen on the thread it was created on
    - transferring a &mut T to another thread is not possible since it would break the protections that !Send has
  - Examples
    - MutexGuard of a T https://users.rust-lang.org/t/example-of-a-type-that-is-not-send/59835/3
      - cannot be dropped in a different thread, so it is not Send
      - If T is sync then it follows from `T : Sync ⇔ &'_ T : Sync` that a `MutexGuard<T>` is Sync

## Lifetime bounds

Structs or types can contain references. In that case they receive a lifetime parameter. 

Syntax:

- Structs: lifetime parameters are written before the generic type arguments. 
- Functions: lifetime parameters are written before the argument list 

Semantics:

- `T: 'a` You can hold on `T` 
  - for the lifetime `'a` 
  - until you move it out

Rules/corollary:

- `&'a T => T: 'a`, since a reference to T of lifetime 'a cannot be valid for 'a if T itself is not valid for 'a

Examples:

- `T: 'static`:
  - `T` does not contain any lifetimes
  - `T` is an owned variable

Quiz questions:

- What is the difference between `T : 'static` and `&'static T`?


## Lifetime bounds in methods


- Why is it sometimes impossible to call a method with a signature (&self), assign the output to something and then later try to use &self again?


## Function traits

Semantics:
- Fn
- FnMut
- FnOnce

Rules:
- `Fn => FnMut => FnOnce`


## Function items

- syntax
  - created with `fn foo() {}`
  - `fn(u32) -> i32 {fn_name}` in error messages
- semantics
  - stateless, pure
   - can be transferred to other threads since there is no risk of data races
  - references to immutable code in compiled binary
    - can easily be cloned or copied  
    - can be optimized away `=>` no pointer needed `=>` zero sized
  - have unique unnameable types


```rust
fn my_function(x: i32) -> i32 {
    x + 1
}

fn main() {
    let f = my_function; // f is a function item (ZST)
    println!("Size of f: {}", std::mem::size_of_val(&f)); // Output: 0
}
```

## Function pointers

- Syntax
    - declared with `fn() -> ()`
    - not a trait
      - so not written with a capital letter.
      - cannot be used as a trait bound
- Semantics
  - Points to 
    - a top-level defined function item
    - an associated function
  - cannot capture from the environment
  - Implements all the following traits Fn, FnMut, and FnOnce
  - size of a pointer, has to be dereferenced,
    - might be slower than calling a function item or closure directly,
    - faster then dyn Fn
  - Primitive type, not a trait



```rust
fn my_function(x: i32) -> i32 {
    x + 1
}

fn main() {
    let f: fn(i32) -> i32 = my_function; // f is a function pointer
    println!("Size of f: {}", std::mem::size_of_val(&f)); // Output: 8 (on 64-bit)
}
```

- How can it be created?
    - non-capturing closures
    - function items with the same signature
- How can it be used?
  - Can be passed as argument to
    - function items
    - other function pointers
  - Can be returned from a function item


When is it particularly useful?
- When using FFI with languages that don't support closures


## Closures


- Alternative names
  - Lambda
- Semantics
  - A function defined in a certain scope that captures reference to variables in the containing scope
  - Creates an implicit struct to store captured data.
  - Has an implicit call method defined
- Syntax
  - Complete type cannot be written explicitly   




## Closures and lifetimes

Lifetime elision rules are different so the following does not compile 

```rust
fn main() {
    let closure = |x: &i32| x; // ❌
}
```

Beause it expands to

```rust 
fn main() {
    // input and output each get their own distinct lifetimes
    let closure = for<'a, 'b> |x: &'a i32| -> &'b i32 { x };
    // note: the above line is not valid syntax, but we need it for illustrative purposes
}
```

Two distinct lifetimes are created for the input and output type. For normal functions, only one lifetime is created.

## Closure implementations

How are they implemented? https://huonw.github.io/blog/2015/05/finding-closure-in-rust/

- the body block of the closure is analyzed
- variables in the body that refer to variables in the surrounding scope are Marked as captured
- struct generated at compile time with as fields the references to the captured variables, it serves as the environment for the closure body
  - the struct is invisible and out of reach for the programmer in normal Rust code
  - This makes closures part of the family of unnameable types (also called Voldemort types)

Disadvantages
- The exact type of a closure struct cannot be written out to type an input or output argument 

Solutions

- A trait object object has to be used

```rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
```

You can change the default behaviour to only create references to the surrounding environment. You can also move variables inside the struct representing the environment of the closure. This is done by using the move keyword.
- takes ownership of variables in the surrounding scope
- inside the closure the variables are used by reference
  - does not make the closure FnOnce in itself


## Variants of closures

There are different kinds of closures based on the signature of their call method on the underlying struct:
- Fn:
    - the signature is call(&self),
    - the body of the closure only may have
        - immutable references to its containing scope
        - values that were moved from the containing scope (and only use them by reference afterwards)
    - can be called from anywhere, multiple times
    - Must implement FnMut
- FnMut:
    - the signature is (& mut self)
    - the closure can have
        - mutable references to its containing scope
        - immutable references to its containing scope
    - cannot consume or move out captured variables
    - can be called more than once, but only once at a time, must implement FnOnce
- FnOnce
    - signature is call(self)
    - can only be called once
    - Can move variables that are moved in out
        - Other words:
            - consume captured variables
            - apply functions to them and call by value, not by reference
        - This means that it is not Fn or FnMut, because those should be able to be called multiple times
    - and mutate,
    - implemented by every closure
  - Only implement copy clone send and sync when their contents do


```rust
trait Trait {
    fn f(&self);
}

impl<F: FnOnce() -> bool> Trait for F {
    fn f(&self) {
        print!("1");
    }
}

impl Trait for () {
    fn f(&self) {
        print!("2");
    }
}

fn main() {
    let x = || { (return) || true; };
    x().f();
}
```
This will output 2. Why?
1. We define a closure x `|| { (return) || true; }`
2. `(return)` is of type `!` because it never completes
3. `(return) || true` is of type `! || true` which evaluates to `bool || true`
4. `bool || true;` evaluates to `()`
5. `f` is implemented for `()` to output `2`.

```rust

fn main() {
    let x = || { return || true; };
    x().f();
}
```
Will output 1 since a call to x returns another closure that returns a bool.


## Type elision / erasure

Sometimes
- we don't know the type
  - the particular instance of a trait we exactly need as input or output for a function signature
  - the actual type is hidden from the user. These types are called unnameable or Voldemort types
- we know the type, but the full type is too long to be readable
  - iterator implementors
  - future combinators (see next session)


solution:
- For local variables 
  - use the wildcard `_`
- In type declarations for functions, traits or structs, 
  - the type cannot be inferred by the compiler
  - use opaque types

   
Benefits of opaque types
- hide specific types,
- cleaner API
- underlying concrete type can be an unnameable type
   

### Trait objects

First type of opaque types is a **trait object**:

- synonyms
  - dynamic dispatch
- syntax
  - Marked with the dyn keyword
- semantics
  - a pointer to an object
  - a pointer to a method table, called a **vtable** with function pointers for each method of the trait
- Disadvantages
  - Cannot be pushed on the stack directly, 
  - has to be on the heap or behind a pointer on the stack
  - Method call is determined at runtime, less optimizations
- How can it be created? Which traits can be used to create trait objects? The ones that are object safe.
    - cannot have generic methods
    - The return type isn't Self.

Question
What is the output of this Rust program?
```rust
trait Base {
    fn method(&self) {
        print!("1");
    }
}

trait Derived: Base {
    fn method(&self) {
        print!("2");
    }
}

struct BothTraits;
impl Base for BothTraits {}
impl Derived for BothTraits {}

fn dynamic_dispatch(x: &dyn Base) {
    x.method();
}

fn static_dispatch<T: Base>(x: T) {
    x.method();
}

fn main() {
    dynamic_dispatch(&BothTraits);
    static_dispatch(BothTraits);
}
```

- Dynamic dispatch: The forwarding is done by reading from a table of function pointers contained within the trait object. Expanded to `<dyn Base as Base>::method`. Since the argument was obtained by converting a BothTraits to dyn Base, the automatically generated implementation detail will wind up forwarding to `<BothTraits as Base>::method` which prints 1.
- Static dispatch: Type inference within generic functions in Rust happens independently of any concrete instantiation of the generic function i.e. before we know what T may be, other than the fact that it implements Base. By the time that T is decided, it has already been determined that x.method() is calling `<T as Base>::method` or `<BothTraits as Base>::method` which prints 1.

### Lifetimes for trait objects

https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md#6-boxed-trait-objects-dont-have-lifetimes

### DSTs

Trait objects are part of the family of dynamically sized types (DST) 

Synonyms
- unsized types
Syntax
- `GenericType<D: ?Sized>`
Semantics
- Types that don't fit on the stack as local variables by value

Examples
- slices: fat pointer has address and length
- trait objects:

Related concepts:
- References to DSTs are called **fat pointers.** https://stackoverflow.com/questions/57754901/what-is-a-fat-pointer

Counterexamples? Most types are not DSTs because their size is known at compile time.
- They implement the trait Sized
- DSTs don't implement Sized

### Impl trait

The other type of opaque types is impl Trait.

Synonyms
- anonymous types

syntax
- written `impl Trait` 
- syntax sugar for hardcoding a specific type that can be inferred by the compiler
- new lifetime capturing rules for return position impl traits? https://blog.rust-lang.org/2024/09/05/impl-trait-capture-rules.html
  - explicit capturing of specific or none of the lifetimes in the arguments
  - consequences: 
    - implementation can be changed 
    - but signature does not have to be changed

semantics
- No extra heap allocation
- No dynamic dispatch overhead

Implementation:
- "return position impl Trait" (RPIT) in Trait definitions (allowed since dec 2023)
  - the anonymous type in the impl T return type is a kind of associated type


## Co-operative vs pre-emptive multitasking

cooperative scheduling does not use "context switching"

Context switching involves storing and restoring the state of an application (or thread). This is costly.

https://stackoverflow.com/questions/46015648/cooperative-scheduling-vs-preemptive-scheduling

## Coroutines

Syntax
- How can I write a coroutine
Semantics
- cooperative multitasking
- What are coroutines https://doc.rust-lang.org/beta/unstable-book/language-features/coroutines.html


Questions:
- What is the difference between a coroutine and a generator
- what is the difference with a green thread?
- What is the difference between stackful and stackless coroutines?

Applications
- How can I write an iterator with a coroutine?

### Stackless couroutines


- What are stackless coroutines?
- How are they implemented in Rust? 
  - State machines, just like state machines representing futures.
  - See
    - https://doc.rust-lang.org/beta/unstable-book/language-features/coroutines.html#coroutines-as-state-machines
    - https://tmandry.gitlab.io/blog/posts/optimizing-await-1/
  
- benefits  
  - no need to create separate stacks per coroutine

## Async-await

- Syntax  
  - Desugars to impl future
  - when async function signatures is used in a trait it is syntax sugar for an RPIT
  - Which bounds are added to the impl Future output type?
- Semantics
  - Concurrent programming
  - Optimizing utilizing computational resources (registers, caches, cores, ...)
  - Not necessarily parallel
- Use cases
  - What are the benefits of asynchronous code?


- What's the best approach for handling structs with lifetimes in asynchronous or multithreaded code? Are there alternatives to avoiding them altogether?
 

### Built-in async traits

https://without.boats/blog/poll-next/

- What are some practical applications of asynchronous iterators?

### Async implementations

[why-async-rust](https://without.boats/blog/why-async-rust/)

- How are asynchronous function implemented?
- What are futures?
- How are references managed across await points in async functions? Where and how are they stored?
- What is the meaning of the Pin type?
- As with every impl Future output type in the new version of Rust, it will captures all lifetime constraints on the arguments. Up until now, a special hack was needed for this.


## Relationships

If every function was a couroutine, you could put the different concepts in a table.

The following diagram comes from https://without.boats/blog/coroutines-async-and-iter/


|                | YIELDS               | RETURNS         | RESUMES         |
|----------------|----------------------|-----------------|-----------------|
|                |                      |                 |                 |
| BASE CASE      | `!`                  | `Self::Output`  | `()`            |
|                |                      |                 |                 |
| FUTURE         | `()`                 | `Self::Output`  | `&mut Context`  |
|                |                      |                 |                 |
| ITERATOR       | `Self::Item`         | `()`            | `()`            |
|                |                      |                 |                 |
| ASYNCITERATOR  | `Poll<Self::Item>`   | `()`            | `&mut Context`  |
|                |                      |                 |                 |


Explanation of table

- normal functions: considered as coroutines, don't yield, so the never type is used for yield. They resume type is only relevant for coroutines that yield, so it is empty for normal functions.
- futures: When a future is viewed as the state of a call to a coroutine, it's poll function is the function that resumes the coroutine. But to poll a future, you need pass the context which contains the waker. The waker is way to notify the async runtime, in case it is currently pending, that in the future the future is ready to be polled again.

- The implementation of Rust async functions is very similar to the implementation of stackless coroutines.

## Tasks

## Runtimes

- How is an asynchronous runtime implemented? [https://tokio.rs/tokio/tutorial/async](https://tokio.rs/tokio/tutorial/async)
- Which asynchronous runtime should I use?

- Does an async runtime use many threads? Or does it create some kind of application level threads?

## Complex asynchronous applications

- When should I pin futures and store them?


## Cutting edge

- Async closures [https://blog.rust-lang.org/inside-rust/2024/08/09/async-closures-call-for-testing.html](https://blog.rust-lang.org/inside-rust/2024/08/09/async-closures-call-for-testing.html)
- async drop