# Types

## Stronger Emphasis on Type Systems

Many functional languages encourage strong static type systems, which can reduce bugs by catching errors at compile time.

## What are types

Examples:

- Primitive types: numbers, arrays, integers, strings
- User types: objects, classes

## Type system

- tool to specify behavior of computer program at compile-time
- can be used as constraints for software

## Role of types

In both mathematics and computer science, types:

- Abstract away, simplify and model problems.
- Add constraints to problem models.

Think about types as specifying *lower bounds* and *upper bounds* to problems.

## Different levels of typing

There is distinction between the following types of languages

1. **Weakly-typed** languages: make conversions between unrelated types implicitly;
2. **strongly-typed** languages: don't allow implicit conversions between unrelated types.

## Primitive data-types

In weakly typed languages such as Python, R, JS the following is possible:

```python
a = 123456789
a = "abcdef"
```

It is also possible to use non-boolean data as a boolean.

For example

```js
let n = 0
if (!n) {
    // do something
}
```

In strongly typed languages such as Haskell, Rust there are more constraints. It is not possible to use a number and boolean interchangeably.

For example, the following is disallowed:

```rust
let mut a : i8 = 123
a = "abc" // compile error
```

## Simple Generic Data types

Some types collect related data in a structure. These container types are **generic** in the sense that they contain **generic** data.

Examples of generic data types are:

- Lists
- Classes
- DataFrames

To use a generic type, you have to specify the content type of the contained type. For example in Rust, a vector or a list of number is denoted by `Vec<u8>`. In this case the **type variable** `T` in `Vec<T>` is set to `u8`

## Logical generic types

Some types do more than just collecting data fields. They also have some logic built-in.

### Function types

A special kind of generic type is a function type. In Rust, for example, a function that maps an integer on an integer is denoted by: `fn(a: u8) -> u8`. Function types are generic because it is possible to swap the input and output type.

For example, the identity function is defined in Rust as

```rust
fn id<T>(t: T) -> T {
    t
}
```

The type variable is `T`.

### Reference types

The type of a reference to a variable of type `u8` is written as `&u8`. The ampersand literally means **a reference** to a `u8`.

This simple type of references is restricted by the [borrowing rules](../05-references). If you want to escape the borrowing rules slightly and have more than a single owner and multiple references, you need a special type called an `Arc`. This is a reference counted pointer. When called like

```rust
let x = Arc::new(0)
let y = x.clone()
```

This will copy a reference `x` to `0` and create a copy of this reference. When it creates the copy reference, it increases a integer variable that keeps track of the number of references. When the number of references becomes zero, the integer being 0 is dropped.

A more advanced version of a reference, is a locked reference. This also called a **mutex**, which stands for **mutually exclusive**. This reference can only expose a location, in case it is locked. This means it can be used to share data in a program. Usually it is used in conjunction with `Arc` as

```rust
let m = Arc::new(Mutex::new(0))
let reference = m.lock().unwrap()
*reference = 1
```


## Types = constraints

In general, a stronger type system means that more constraints can be imposed on your software. And what's even better, is that these constraints can be verified at compile-time before the software is run.

A lack of constraints leads to unpredictable software. Unpredictable software leads to:

- Angry users
- Tired developers
- Bad business

Languages such as C++ impose fewer constraints on the program, which makes them at first sight easier, because less rules have to be learned. But in the long term, you will encounter more bugs such as "data races" and others if you impose less contraints.

## 4. Algebraic Data Types (ADTs)

### Sums

We can compose types via "sums" (e.g., enums). These  provide a way to define a type by enumerating its possible variants.

For example,

```rust
enum CellState {
    Alive,
    Dead,
    Dormant,
}
```

### Products

You can also bundle several values together into records that are called **products**. In some sense, classes are a kind of product.

**Biology Example in Rust:**

```rust
struct Cell {
    state: CellState,
    energy_level: u32,
}
```

In R, data-frames are products. In JavaScript, JSON objects are also a form of products.

### Combining

By combining sum types (`enums`) and product types (`structs`), we can model cell states and behaviors comprehensively. In Rust, we can implement a method for checking the cell state. This means function programming is compatible with object-oriented programming.

```rust
impl Cell {
    fn check_cell_state(self) -> CellState {
        match cell.state {
            CellState::Alive if cell.energy_level > 10 => CellState::Alive,
            _ => CellState::Dead,
        }
    }
}
```
