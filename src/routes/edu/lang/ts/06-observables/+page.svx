# Publisher-subscriber pattern

Work in progress.

One of the patterns from the [Design-patterns](https://www.amazon.co.uk/Design-patterns-elements-reusable-object-oriented/dp/0201633612) book is the publisher-subscriber pattern. It is a way to keep track of changing state.

This works by having both a subscriber and a publisher:

- One or more **subscriber**s: these are objects that want to be notified by the publisher through a subscription. An alternative name for a subscriber is *observer*. Observers are kept alive by the garbage collector if their subscription is never cancelled.
- A **publisher**: an object that models data flow or a variable, changing through time. A publisher has a subscribe method that is used to send data to a newly made subscriber. It should also allow for the cancellation of subscription. 
    - Unicast: In RxJS a unicast publisher is called an *observable*. 
    - Multi-cast: an explicit list of subscribers is maintained and all of them are notified of changes. This is called a **subject**
 
In RxJS, a subject with an initial value, is called a **behavior subject**. 
In Svelte, such a subject is called a writable store. See [Svelte](https://learn.svelte.dev/tutorial/welcome-to-svelte). In Svelte, a writable store is implemented using the *store contract*, an interface that is compatible with the subjects from RxJS

## Stores

A writable store can be given extra functionality. For example a store can be given memory to be able to revert to one or more previous values.

## Store bindings

Two-way:

- Bind: Two stores can be attached through a two-way transformation.

One-way:

- Project: converts a stream into one of it's components
- Merge: merges a list of streams into a combined stream

## Operators on stores

Instead of binding stores to each-other, you can also create new stores from existing stores. One example is a deep filter. This filters a store of stores based on the value of the smaller individual stores.

## Signals

An implicit version of the store pattern is signals. Signals make use of getters to read and update state. Subscription happens inside effects. Effects track dependencies between signals at run-time.

For a simple implementation, see https://dev.to/ratiu5/implementing-signals-from-scratch-3e4c.

## History of reactive programming

In order of appearance:

- Knockout: https://knockoutjs.com/documentation/observables.html
- Angular https://angular.io/guide/signals.
- SolidJS: https://www.solidjs.com/docs/latest/api#createsignal
- Leptos: a framework for WebAssembly in Rust https://github.com/leptos-rs/leptos
- The newest version of Svelte, 5, uses signals instead of stores. It switched from compile-time reactivity to run-time reactivity.
